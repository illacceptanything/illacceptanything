(function() {
var define, requireModule, require, requirejs;

(function() {
  var registry = {}, seen = {};

  define = function(name, deps, callback) {
    registry[name] = { deps: deps, callback: callback };
  };

  requirejs = require = requireModule = function(name) {
  requirejs._eak_seen = registry;

    if (seen[name]) { return seen[name]; }
    seen[name] = {};

    if (!registry[name]) {
      throw new Error("Could not find module " + name);
    }

    var mod = registry[name],
        deps = mod.deps,
        callback = mod.callback,
        reified = [],
        exports;

    for (var i=0, l=deps.length; i<l; i++) {
      if (deps[i] === 'exports') {
        reified.push(exports = {});
      } else {
        reified.push(requireModule(resolve(deps[i])));
      }
    }

    var value = callback.apply(this, reified);
    return seen[name] = exports || value;

    function resolve(child) {
      if (child.charAt(0) !== '.') { return child; }
      var parts = child.split("/");
      var parentBase = name.split("/").slice(0, -1);

      for (var i=0, l=parts.length; i<l; i++) {
        var part = parts[i];

        if (part === '..') { parentBase.pop(); }
        else if (part === '.') { continue; }
        else { parentBase.push(part); }
      }

      return parentBase.join("/");
    }
  };
})();

define("promise/all", 
  ["./utils","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    /* global toString */

    var isArray = __dependency1__.isArray;
    var isFunction = __dependency1__.isFunction;

    /**
      Returns a promise that is fulfilled when all the given promises have been
      fulfilled, or rejected if any of them become rejected. The return promise
      is fulfilled with an array that gives all the values in the order they were
      passed in the `promises` array argument.

      Example:

      ```javascript
      var promise1 = RSVP.resolve(1);
      var promise2 = RSVP.resolve(2);
      var promise3 = RSVP.resolve(3);
      var promises = [ promise1, promise2, promise3 ];

      RSVP.all(promises).then(function(array){
        // The array here would be [ 1, 2, 3 ];
      });
      ```

      If any of the `promises` given to `RSVP.all` are rejected, the first promise
      that is rejected will be given as an argument to the returned promises's
      rejection handler. For example:

      Example:

      ```javascript
      var promise1 = RSVP.resolve(1);
      var promise2 = RSVP.reject(new Error("2"));
      var promise3 = RSVP.reject(new Error("3"));
      var promises = [ promise1, promise2, promise3 ];

      RSVP.all(promises).then(function(array){
        // Code here never runs because there are rejected promises!
      }, function(error) {
        // error.message === "2"
      });
      ```

      @method all
      @for RSVP
      @param {Array} promises
      @param {String} label
      @return {Promise} promise that is fulfilled when all `promises` have been
      fulfilled, or rejected if any of them become rejected.
    */
    function all(promises) {
      /*jshint validthis:true */
      var Promise = this;

      if (!isArray(promises)) {
        throw new TypeError('You must pass an array to all.');
      }

      return new Promise(function(resolve, reject) {
        var results = [], remaining = promises.length,
        promise;

        if (remaining === 0) {
          resolve([]);
        }

        function resolver(index) {
          return function(value) {
            resolveAll(index, value);
          };
        }

        function resolveAll(index, value) {
          results[index] = value;
          if (--remaining === 0) {
            resolve(results);
          }
        }

        for (var i = 0; i < promises.length; i++) {
          promise = promises[i];

          if (promise && isFunction(promise.then)) {
            promise.then(resolver(i), reject);
          } else {
            resolveAll(i, promise);
          }
        }
      });
    }

    __exports__.all = all;
  });
define("promise/asap", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var browserGlobal = (typeof window !== 'undefined') ? window : {};
    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
    var local = (typeof global !== 'undefined') ? global : (this === undefined? window:this);

    // node
    function useNextTick() {
      return function() {
        process.nextTick(flush);
      };
    }

    function useMutationObserver() {
      var iterations = 0;
      var observer = new BrowserMutationObserver(flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    function useSetTimeout() {
      return function() {
        local.setTimeout(flush, 1);
      };
    }

    var queue = [];
    function flush() {
      for (var i = 0; i < queue.length; i++) {
        var tuple = queue[i];
        var callback = tuple[0], arg = tuple[1];
        callback(arg);
      }
      queue = [];
    }

    var scheduleFlush;

    // Decide what async method to use to triggering processing of queued callbacks:
    if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
      scheduleFlush = useNextTick();
    } else if (BrowserMutationObserver) {
      scheduleFlush = useMutationObserver();
    } else {
      scheduleFlush = useSetTimeout();
    }

    function asap(callback, arg) {
      var length = queue.push([callback, arg]);
      if (length === 1) {
        // If length is 1, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        scheduleFlush();
      }
    }

    __exports__.asap = asap;
  });
define("promise/config", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var config = {
      instrument: false
    };

    function configure(name, value) {
      if (arguments.length === 2) {
        config[name] = value;
      } else {
        return config[name];
      }
    }

    __exports__.config = config;
    __exports__.configure = configure;
  });
define("promise/polyfill", 
  ["./promise","./utils","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    /*global self*/
    var RSVPPromise = __dependency1__.Promise;
    var isFunction = __dependency2__.isFunction;

    function polyfill() {
      var local;

      if (typeof global !== 'undefined') {
        local = global;
      } else if (typeof window !== 'undefined' && window.document) {
        local = window;
      } else {
        local = self;
      }

      var es6PromiseSupport = 
        "Promise" in local &&
        // Some of these methods are missing from
        // Firefox/Chrome experimental implementations
        "resolve" in local.Promise &&
        "reject" in local.Promise &&
        "all" in local.Promise &&
        "race" in local.Promise &&
        // Older version of the spec had a resolver object
        // as the arg rather than a function
        (function() {
          var resolve;
          new local.Promise(function(r) { resolve = r; });
          return isFunction(resolve);
        }());

      if (!es6PromiseSupport) {
        local.Promise = RSVPPromise;
      }
    }

    __exports__.polyfill = polyfill;
  });
define("promise/promise", 
  ["./config","./utils","./all","./race","./resolve","./reject","./asap","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {
    "use strict";
    var config = __dependency1__.config;
    var configure = __dependency1__.configure;
    var objectOrFunction = __dependency2__.objectOrFunction;
    var isFunction = __dependency2__.isFunction;
    var now = __dependency2__.now;
    var all = __dependency3__.all;
    var race = __dependency4__.race;
    var staticResolve = __dependency5__.resolve;
    var staticReject = __dependency6__.reject;
    var asap = __dependency7__.asap;

    var counter = 0;

    config.async = asap; // default async is asap;

    function Promise(resolver) {
      if (!isFunction(resolver)) {
        throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
      }

      if (!(this instanceof Promise)) {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }

      this._subscribers = [];

      invokeResolver(resolver, this);
    }

    function invokeResolver(resolver, promise) {
      function resolvePromise(value) {
        resolve(promise, value);
      }

      function rejectPromise(reason) {
        reject(promise, reason);
      }

      try {
        resolver(resolvePromise, rejectPromise);
      } catch(e) {
        rejectPromise(e);
      }
    }

    function invokeCallback(settled, promise, callback, detail) {
      var hasCallback = isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        try {
          value = callback(detail);
          succeeded = true;
        } catch(e) {
          failed = true;
          error = e;
        }
      } else {
        value = detail;
        succeeded = true;
      }

      if (handleThenable(promise, value)) {
        return;
      } else if (hasCallback && succeeded) {
        resolve(promise, value);
      } else if (failed) {
        reject(promise, error);
      } else if (settled === FULFILLED) {
        resolve(promise, value);
      } else if (settled === REJECTED) {
        reject(promise, value);
      }
    }

    var PENDING   = void 0;
    var SEALED    = 0;
    var FULFILLED = 1;
    var REJECTED  = 2;

    function subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      subscribers[length] = child;
      subscribers[length + FULFILLED] = onFulfillment;
      subscribers[length + REJECTED]  = onRejection;
    }

    function publish(promise, settled) {
      var child, callback, subscribers = promise._subscribers, detail = promise._detail;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        invokeCallback(settled, child, callback, detail);
      }

      promise._subscribers = null;
    }

    Promise.prototype = {
      constructor: Promise,

      _state: undefined,
      _detail: undefined,
      _subscribers: undefined,

      then: function(onFulfillment, onRejection) {
        var promise = this;

        var thenPromise = new this.constructor(function() {});

        if (this._state) {
          var callbacks = arguments;
          config.async(function invokePromiseCallback() {
            invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
          });
        } else {
          subscribe(this, thenPromise, onFulfillment, onRejection);
        }

        return thenPromise;
      },

      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };

    Promise.all = all;
    Promise.race = race;
    Promise.resolve = staticResolve;
    Promise.reject = staticReject;

    function handleThenable(promise, value) {
      var then = null,
      resolved;

      try {
        if (promise === value) {
          throw new TypeError("A promises callback cannot return that same promise.");
        }

        if (objectOrFunction(value)) {
          then = value.then;

          if (isFunction(then)) {
            then.call(value, function(val) {
              if (resolved) { return true; }
              resolved = true;

              if (value !== val) {
                resolve(promise, val);
              } else {
                fulfill(promise, val);
              }
            }, function(val) {
              if (resolved) { return true; }
              resolved = true;

              reject(promise, val);
            });

            return true;
          }
        }
      } catch (error) {
        if (resolved) { return true; }
        reject(promise, error);
        return true;
      }

      return false;
    }

    function resolve(promise, value) {
      if (promise === value) {
        fulfill(promise, value);
      } else if (!handleThenable(promise, value)) {
        fulfill(promise, value);
      }
    }

    function fulfill(promise, value) {
      if (promise._state !== PENDING) { return; }
      promise._state = SEALED;
      promise._detail = value;

      config.async(publishFulfillment, promise);
    }

    function reject(promise, reason) {
      if (promise._state !== PENDING) { return; }
      promise._state = SEALED;
      promise._detail = reason;

      config.async(publishRejection, promise);
    }

    function publishFulfillment(promise) {
      publish(promise, promise._state = FULFILLED);
    }

    function publishRejection(promise) {
      publish(promise, promise._state = REJECTED);
    }

    __exports__.Promise = Promise;
  });
define("promise/race", 
  ["./utils","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    /* global toString */
    var isArray = __dependency1__.isArray;

    /**
      `RSVP.race` allows you to watch a series of promises and act as soon as the
      first promise given to the `promises` argument fulfills or rejects.

      Example:

      ```javascript
      var promise1 = new RSVP.Promise(function(resolve, reject){
        setTimeout(function(){
          resolve("promise 1");
        }, 200);
      });

      var promise2 = new RSVP.Promise(function(resolve, reject){
        setTimeout(function(){
          resolve("promise 2");
        }, 100);
      });

      RSVP.race([promise1, promise2]).then(function(result){
        // result === "promise 2" because it was resolved before promise1
        // was resolved.
      });
      ```

      `RSVP.race` is deterministic in that only the state of the first completed
      promise matters. For example, even if other promises given to the `promises`
      array argument are resolved, but the first completed promise has become
      rejected before the other promises became fulfilled, the returned promise
      will become rejected:

      ```javascript
      var promise1 = new RSVP.Promise(function(resolve, reject){
        setTimeout(function(){
          resolve("promise 1");
        }, 200);
      });

      var promise2 = new RSVP.Promise(function(resolve, reject){
        setTimeout(function(){
          reject(new Error("promise 2"));
        }, 100);
      });

      RSVP.race([promise1, promise2]).then(function(result){
        // Code here never runs because there are rejected promises!
      }, function(reason){
        // reason.message === "promise2" because promise 2 became rejected before
        // promise 1 became fulfilled
      });
      ```

      @method race
      @for RSVP
      @param {Array} promises array of promises to observe
      @param {String} label optional string for describing the promise returned.
      Useful for tooling.
      @return {Promise} a promise that becomes fulfilled with the value the first
      completed promises is resolved with if the first completed promise was
      fulfilled, or rejected with the reason that the first completed promise
      was rejected with.
    */
    function race(promises) {
      /*jshint validthis:true */
      var Promise = this;

      if (!isArray(promises)) {
        throw new TypeError('You must pass an array to race.');
      }
      return new Promise(function(resolve, reject) {
        var results = [], promise;

        for (var i = 0; i < promises.length; i++) {
          promise = promises[i];

          if (promise && typeof promise.then === 'function') {
            promise.then(resolve, reject);
          } else {
            resolve(promise);
          }
        }
      });
    }

    __exports__.race = race;
  });
define("promise/reject", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      `RSVP.reject` returns a promise that will become rejected with the passed
      `reason`. `RSVP.reject` is essentially shorthand for the following:

      ```javascript
      var promise = new RSVP.Promise(function(resolve, reject){
        reject(new Error('WHOOPS'));
      });

      promise.then(function(value){
        // Code here doesn't run because the promise is rejected!
      }, function(reason){
        // reason.message === 'WHOOPS'
      });
      ```

      Instead of writing the above, your code now simply becomes the following:

      ```javascript
      var promise = RSVP.reject(new Error('WHOOPS'));

      promise.then(function(value){
        // Code here doesn't run because the promise is rejected!
      }, function(reason){
        // reason.message === 'WHOOPS'
      });
      ```

      @method reject
      @for RSVP
      @param {Any} reason value that the returned promise will be rejected with.
      @param {String} label optional string for identifying the returned promise.
      Useful for tooling.
      @return {Promise} a promise that will become rejected with the given
      `reason`.
    */
    function reject(reason) {
      /*jshint validthis:true */
      var Promise = this;

      return new Promise(function (resolve, reject) {
        reject(reason);
      });
    }

    __exports__.reject = reject;
  });
define("promise/resolve", 
  ["exports"],
  function(__exports__) {
    "use strict";
    function resolve(value) {
      /*jshint validthis:true */
      if (value && typeof value === 'object' && value.constructor === this) {
        return value;
      }

      var Promise = this;

      return new Promise(function(resolve) {
        resolve(value);
      });
    }

    __exports__.resolve = resolve;
  });
define("promise/utils", 
  ["exports"],
  function(__exports__) {
    "use strict";
    function objectOrFunction(x) {
      return isFunction(x) || (typeof x === "object" && x !== null);
    }

    function isFunction(x) {
      return typeof x === "function";
    }

    function isArray(x) {
      return Object.prototype.toString.call(x) === "[object Array]";
    }

    // Date.now is not available in browsers < IE9
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility
    var now = Date.now || function() { return new Date().getTime(); };


    __exports__.objectOrFunction = objectOrFunction;
    __exports__.isFunction = isFunction;
    __exports__.isArray = isArray;
    __exports__.now = now;
  });
requireModule('promise/polyfill').polyfill();
}());;
;
/* global Platform */

(function () {

  var currentScript = document._currentScript || document.currentScript;

  var BrickAppbarElementPrototype = Object.create(HTMLElement.prototype);

  // Lifecycle methods
  BrickAppbarElementPrototype.attachedCallback = function () {

    var importDoc = currentScript.ownerDocument;
    var template = importDoc.querySelector('#brick-appbar-template');

    // fix styling for polyfill
    if (Platform.ShadowCSS) {
      var styles = template.content.querySelectorAll('style');
      for (var i = 0; i < styles.length; i++) {
        var style = styles[i];
        var cssText = Platform.ShadowCSS.shimStyle(style, 'brick-appbar');
        Platform.ShadowCSS.addCssToDocument(cssText);
        style.remove();
      }
    }

    // create shadowRoot and append template to it.
    var shadowRoot = this.createShadowRoot();
    shadowRoot.appendChild(template.content.cloneNode(true));
  };

  if (!window.BrickAppbarElement) {
    window.BrickAppbarElement = document.registerElement('brick-appbar', {
      prototype: BrickAppbarElementPrototype
    });
  }

})();
;
/* global Platform */

(function() {

  var currentScript = document._currentScript || document.currentScript;

  // used in mouse events
  var LEFT_MOUSE_BTN = 0;

  // constants used in tracking the type of the current drag/paint operation
  var DRAG_ADD = "add";
  var DRAG_REMOVE = "remove";

  // constant representing the class of a day that has been
  // chosen/toggled/selected/whatever
  var chosenClass = "chosen";

  // minifier-friendly strings
  var className = 'className';

  // used during creating calendar elements
  var defaultLabels = {
    prev: '←',
    next: '→',
    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
      'August', 'September', 'October', 'November', 'December'
    ],
    weekdays: ['Sun', "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  };

  /** returns the given date, but as a Date object representing that date
    without local/timezone information

    ***IMPORTANT*** call this anytime we create a new Date(), in order to
    ensure avoid oddities caused by mixing and matching timezone offsets
  **/
  function normalize(localDate) {
    // don't try to reconvert a date already set to UTC time, or
    // the inherent timezone information of JS Dates may change an already
    // converted date
    var normalizedDate = new Date(localDate.valueOf());

    normalizedDate.setHours(0);
    normalizedDate.setMinutes(0);
    normalizedDate.setSeconds(0);
    normalizedDate.setMilliseconds(0);

    return normalizedDate;
  }

  // the current date, set to midnight UTC time
  var TODAY = normalize(new Date());

  // wrapper for parseInt(*, 10) to make jshint happy about radix params
  // also minification-friendly
  function parseIntDec(num) {
    return parseInt(num, 10);
  }

  /** isWeekdayNum: (*) => Boolean

  Checks if the given parameter is a valid weekday number 0-6
  (0=Sunday, 1=Monday, etc)
  **/
  function isWeekdayNum(dayNum) {
    var dayInt = parseIntDec(dayNum);
    return (dayInt === dayNum && (!isNaN(dayInt)) &&
      dayInt >= 0 && dayInt <= 6);
  }

  /** isValidDateObj: (*) => Boolean

  simply checks if the given parameter is a valid date object
  **/
  function isValidDateObj(d) {
    return (d instanceof Date) && !!(d.getTime) && !isNaN(d.getTime());
  }

  /** isArray: (*) => Boolean

  simply checks if the given parameter is an array
  **/
  function isArray(a) {
    if (a && a.isArray) {
      return a.isArray();
    } else {
      return Object.prototype.toString.call(a) === "[object Array]";
    }
  }

  /** makeEl: String => DOM Element

  Takes a string in the format of "tag.classname.classname2" (etc) and
  returns a DOM element of that type with the given classes

  For example, makeEl('div.foo') returns the Node <div class="foo">
  **/
  function makeEl(s) {
    var a = s.split('.');
    var tag = a.shift();
    var el = document.createElement(tag);
    el[className] = a.join(' ');
    return el;
  }

  /** pad: (Number, Number) => String

  Pads a number with preceding zeros to be padSize digits long

  If given a number with more than padSize digits, truncates the leftmost
  digits to get to a padSize length
  **/
  function pad(n, padSize) {
    var str = n.toString();
    var padZeros = (new Array(padSize)).join('0');
    return (padZeros + str).substr(-padSize);
  }

  /** iso: Date => String

  returns the ISO format representation of a date ("YYYY-MM-DD")
  **/
  function iso(d) {
    return [
      pad(d.getFullYear(), 4),
      pad(d.getMonth() + 1, 2),
      pad(d.getDate(d), 2)
    ].join('-');
  }

  /** fromIso: String => Date/null

  Given a string, attempts to parse out a date in YYYY-MM-DD format

  If successful, returns the corresponding Date object, otherwise return null
  **/
  var ISO_DATE_REGEX = /(\d{4})[^\d]?(\d{2})[^\d]?(\d{2})/;

  function fromIso(s) {
    if (isValidDateObj(s)) {
      return s;
    }
    var d = ISO_DATE_REGEX.exec(s);
    if (d) {
      return normalize(new Date(d[1], d[2] - 1, d[3]));
    } else {
      return null;
    }
  }

  /** parseSingleDate: String => Date/null

  attempts to parse out the given string as a Date

  If successful, returns the corresponding Date object, otherwise return null

  Valid input formats include any format with a YYYY-MM-DD format or
  is parseable by Date.parse
  **/
  function parseSingleDate(dateStr) {
    if (isValidDateObj(dateStr)) {
      return dateStr;
    }

    // cross-browser check for ISO format that is not
    // supported by Date.parse without implicit time zone
    var isoParsed = fromIso(dateStr);
    if (isoParsed) {
      return isoParsed;
    } else {
      var parsedMs = Date.parse(dateStr);
      if (!isNaN(parsedMs)) {
        return normalize(new Date(parsedMs));
      }
      return null;
    }
  }

  /** parseMultiDates: Array/String => (Date/[Date, Date]) array/null

  Given either an array or a JSON string, attempts to parse out the input into
  the given array format:
   - An array whose elements fall into one of the following two formats
    - A Date object representing a single day
      (if the input uses a string instead, this parser will attempt to
       parseSingleDate it)
    - A two element list of Date objects representing the start and
      end dates of a range (if the inputs use strings instead, the parser
      will attempt to parseSingleDate them)

  If the input is parseable into this format, return the resulting 2d array
  Otherwise, return null and console.warn the parsing error

  If given an array that already follows this format, will simply return it
  **/
  function parseMultiDates(multiDateStr) {
    var ranges;
    if (isArray(multiDateStr)) {
      ranges = multiDateStr.slice(0); // so that this is nondestructive
    } else if (isValidDateObj(multiDateStr)) {
      return [multiDateStr];
    } else if (typeof(multiDateStr) === "string" && multiDateStr.length > 0) {
      // check if this is a JSON representing a range of dates
      try {
        ranges = JSON.parse(multiDateStr);
        if (!isArray(ranges)) {
          return null;
        }
      } catch (err) {
        // check for if this represents a single date
        var parsedSingle = parseSingleDate(multiDateStr);
        if (parsedSingle) {
          return [parsedSingle];
        } else {
          return null;
        }
      }
    } else {
      return null;
    }

    // go through and replace each unparsed range with its parsed
    // version (either a singular Date object or a two-item list of
    // a start Date and an end Date)
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];

      if (isValidDateObj(range)) {
        continue;
      }
      // parse out as single date
      else if (typeof(range) === "string") {
        var parsedDate = parseSingleDate(range);
        if (!parsedDate) {
          return null;
        }
        ranges[i] = parsedDate;
      }
      // parse out as 2-item list/range of start/end date
      else if (isArray(range) && range.length === 2) {
        var parsedStartDate = parseSingleDate(range[0]);

        if (!parsedStartDate) {
          return null;
        }

        var parsedEndDate = parseSingleDate(range[1]);
        if (!parsedEndDate) {
          return null;
        }

        if (parsedStartDate.valueOf() > parsedEndDate.valueOf()) {
          return null;
        }
        ranges[i] = [parsedStartDate, parsedEndDate];
      } else {
        return null;
      }
    }
    return ranges;
  }

  /* from: (Date, number, number, number) => Date

  Create a new date based on the provided date, but with any given
  year/month/date parameters in place of the base date's
  */
  function from(base, y, m, d) {
    if (y === undefined) {
      y = base.getFullYear();
    }
    if (m === undefined) {
      m = base.getMonth();
    }
    if (d === undefined) {
      d = base.getDate();
    }
    return normalize(new Date(y, m, d));
  }

  /* daysInMonth: (month) => Number

  Returns the number of days in the month specified
  */

  function daysInMonth(month, year) {
    if (!year) {
      year = (new Date()).getFullYear();
    }
    return (new Date(year, month + 1, 0)).getDate();
  }

  /* relOffset: (Date, number, number. number) => Date

  get the date with the given offsets from the base date

  ex: relOffset(foo, 0, -1, 0) returns the date that is exactly one month
    behind foo
  */
  function relOffset(base, y, m, d) {
    return from(base,
      base.getFullYear() + y,
      base.getMonth() + m,
      base.getDate() + d);
  }

  function nextMonth(d) {
    var date = d.getDate();
    var daysInNextMonth = daysInMonth(d.getMonth() + 1, d.getFullYear());
    if (date > daysInNextMonth) {
      date = daysInNextMonth;
    }
    return new Date(d.getFullYear(), d.getMonth() + 1, date);
  }

  function prevMonth(d) {
    var date = d.getDate();
    var daysInPrevMonth = daysInMonth(d.getMonth() - 1, d.getFullYear());
    if (date > daysInPrevMonth) {
      date = daysInPrevMonth;
    }
    return new Date(d.getFullYear(), d.getMonth() - 1, date);
  }

  /** findWeekStart: Date => Date

  Find the date that is the beginning of the given date's week.

  This defaults to finding the nearest Sunday before or on the given date,
  but if firstWeekday is given as a number 0-6 (0=Sunday, 1=Monday, etc),
  that day will be used instead
  **/
  function findWeekStart(d, firstWeekday) {
    firstWeekday = parseIntDec(firstWeekday);
    if (!isWeekdayNum(firstWeekday)) {
      firstWeekday = 0;
    }

    for (var step = 0; step < 7; step++) {
      if (d.getDay() === firstWeekday) {
        return d;
      } else {
        d = prevDay(d);
      }
    }
    throw "unable to find week start";
  }

  /** findWeekEnd: Date => Date

  Find the date that is the beginning of the given date's week.

  This defaults to finding the nearest Saturday after or on the given date,
  but if lastWeekday is given as a number 0-6 (0=Sunday, 1=Monday, etc),
  that day will be used instead
  **/
  function findWeekEnd(d, lastWeekDay) {
    lastWeekDay = parseIntDec(lastWeekDay);
    if (!isWeekdayNum(lastWeekDay)) {
      lastWeekDay = 6;
    }

    for (var step = 0; step < 7; step++) {
      if (d.getDay() === lastWeekDay) {
        return d;
      } else {
        d = nextDay(d);
      }
    }
    throw "unable to find week end";
  }

  /** findFirst: Date => Date

  Find the first day of the date's month.
  **/
  function findFirst(d) {
    d = new Date(d.valueOf());
    d.setDate(1);
    return normalize(d);
  }

  /** findLast: Date => Date

  Find the last day of the date's month.
  **/
  function findLast(d) {
    return prevDay(relOffset(d, 0, 1, 0));
  }

  /** nextDay: Date => Date

  Return the day that comes after the given date's
  **/
  function nextDay(d) {
    return relOffset(d, 0, 0, 1);
  }

  /** prevDay: Date => Date

  Return the day that comes before the given date's
  **/
  function prevDay(d) {
    return relOffset(d, 0, 0, -1);
  }

  /** dateMatches: (Date, (Date/[Date, Date]) array) => Boolean

  Check whether Date `d` is in the list of Date/Date ranges in `matches`.

  If given a single date to check, will check if the two dates fall on the
  same date

  If given an array of Dates/2-item Dateranges (ie: the same format returned
  by parseMultipleDates and used for Calendar._chosenRanges)

  params:
    d                   the date to compare
    matches             if given as a singular date, will check if d is
              in the same date
              Otherwise,
  **/
  function dateMatches(d, matches) {
    if (!matches) {
      return;
    }
    matches = (matches.length === undefined) ? [matches] : matches;
    var foundMatch = false;
    matches.forEach(function(match) {
      if (match.length === 2) {
        if (dateInRange(match[0], match[1], d)) {
          foundMatch = true;
        }
      } else {
        if (iso(match) === iso(d)) {
          foundMatch = true;
        }
      }
    });
    return foundMatch;
  }

  /** dateInRange: (Date, Date, Date) => Boolean

  returns true if the date of the given d date (without time information)
  is in between the start and end days
  **/
  function dateInRange(start, end, d) {
    // convert to strings for easier comparison
    return iso(start) <= iso(d) && iso(d) <= iso(end);
  }


  /** sortRanges: (Date/[Date, Date]) array

  given a list of singular dates / 2-item date range lists (ie: the
  same format as returned by parseMultipleDates and used by
  Calendar._chosenRanges), destructively sorts the list to have
  earlier dates come first
  **/
  function sortRanges(ranges) {
    ranges.sort(function(rangeA, rangeB) {
      var dateA = (isValidDateObj(rangeA)) ? rangeA : rangeA[0];
      var dateB = (isValidDateObj(rangeB)) ? rangeB : rangeB[0];
      return dateA.valueOf() - dateB.valueOf();
    });
  }

  /** makeControls: (data map) => DOM element

  creates and returns the HTML element used to hold the
  navigation controls of the calendar
  **/
  function makeControls(labelData) {
    var controls = makeEl('div.controls');
    var prev = makeEl('span.prev');
    var next = makeEl('span.next');
    prev.setAttribute('role', 'button');
    next.setAttribute('role', 'button');
    prev.innerHTML = labelData.prev;
    next.innerHTML = labelData.next;
    controls.appendChild(prev);
    controls.appendChild(next);
    return controls;
  }


  /** Calendar: datamap

  A representation of the currently displayed calendar's attributes

  Initialized with an optional data map containing any of the following:

   -  "span"  :       The number of months to display at once
            (default = 1)
  -  "multiple"  :    Whether or not multiple dates are allowed to be chosen
            at once
            (default = false)
  -   "view"  :       The cursor date to center the calendar display on
            For example, a view of Dec 2013 and span 3 will show
            a calendar encompassing Nov 2013, Dec 2013, and Jan 2014
            (default = the first date given in data.chosen, or
                   the current date if data.chosen is
                   unavailable)
  -   "chosen"  :     A Date/[Date, Date] array, similar to the format of
            parseMultipleDates' return value
            Elements consist of both singular Dates and 2-element
            arrays of Dates representing the start and end dates
            of a date range
            (default: [data.view], or [],
                  if data.view is unavailable)
  - "firstWeekdayNum" :  A number 0-6 (where 0=Sunday, 1=Monday, etc)
               indicating which day should be used as the start of
               any given week
               (this is useful for regions whose weeks start with
              Monday instead of Sunday)
  **/
  function Calendar(data) {
    // reassign this to minification friendly variable
    var self = this;
    data = data || {};
    self._span = data.span || 1;
    self._multiple = data.multiple || false;
    // initialize private vars
    self._viewDate = self._sanitizeViewDate(data.view, data.chosen);
    self._chosenRanges = self._sanitizeChosenRanges(data.chosen,
      data.view);
    self._firstWeekdayNum = parseIntDec(data.firstWeekdayNum) || 0;

    // Note that self._el is the .calendar child div,
    // NOT the brick-calendar itself
    self._el = makeEl('div.calendar');
    self._labels = defaultLabels;

    self._customRenderFn = null;
    self._renderRecursionFlag = false;

    self.render(true);
  }
  // minification friendly variable for Calendar.prototype
  var CalendarPrototype = Calendar.prototype;

  /** makeMonth: (Date) => DOM element

  For the given view/cursor date's month, creates the HTML DOM elements
  needed to represent this month in the calendar

  Days are created with a data-date attribute containing the ISO string
  representing their date

  For any date that is contained by the given chosen ranges, sets 'chosen'
  classes so that they are marked as chosen for styling

  Also marks the current date with the 'today' class

  params:
    d               the date whose month we will be rendering
  **/
  CalendarPrototype.makeMonth = function(d) {
    if (!isValidDateObj(d)) {
      throw 'Invalid view date!';
    }
    var firstWeekday = this.firstWeekdayNum;
    var chosen = this.chosen;
    var labels = this.labels;

    var month = d.getMonth();
    var sDate = findWeekStart(findFirst(d), firstWeekday);

    var monthEl = makeEl('div.month');
    monthEl.setAttribute('role', 'grid');
    // create month label
    var monthLabel = makeEl('div.month-label');
    monthLabel.textContent = labels.months[month] + ' ' + d.getFullYear();

    monthEl.appendChild(monthLabel);

    // create the weekday labels
    var weekdayLabels = makeEl('div.weekday-labels');
    for (var step = 0; step < 7; step++) {
      var weekdayNum = (firstWeekday + step) % 7;
      var weekdayLabel = makeEl('span.weekday-label');
      weekdayLabel.textContent = labels.weekdays[weekdayNum];
      weekdayLabels.appendChild(weekdayLabel);
    }
    monthEl.appendChild(weekdayLabels);


    // create each week of days in the month
    var week = makeEl('div.week');
    var cDate = sDate;
    var maxDays = 7 * 6; // maximum is 6 weeks displayed at once

    for (step = 0; step < maxDays; step++) {
      var day = makeEl('span.day');
      day.setAttribute('data-date', iso(cDate));
      day.setAttribute('role', 'gridcell');
      day.textContent = cDate.getDate();

      // give each day a class based on which day of the week it is.
      day.classList.add('day-' + (firstWeekday + step) % 7);

      if (cDate.getMonth() !== month) {
        day.classList.add('badmonth');
      }

      if (dateMatches(cDate, chosen)) {
        day.classList.add(chosenClass);
      }

      if (dateMatches(cDate, TODAY)) {
        day.classList.add("today");
      }

      week.appendChild(day);
      cDate = nextDay(cDate);
      // if the next day starts a new week, append finished week and see if
      // we are done drawing the month
      if ((step + 1) % 7 === 0) {
        monthEl.appendChild(week);
        week = makeEl('div.week');
        // Are we finished drawing the month?
        // Checks month rollover and year rollover
        // (ie: if month or year are after the current ones)
        var done = (cDate.getMonth() > month ||
          (cDate.getMonth(cDate) < month &&
            cDate.getYear(cDate) > sDate.getYear())
        );
        if (done) {
          break;
        }
      }
    }
    return monthEl;
  };


  /** Calendar._sanitizeViewDate:
        (Date, (Date/[Date,Date]) array / Date) => Date

  given a view Date and an optional chosen range list or chosen date,
  return the Date to use as the view, depending on what information is given

  returns the given view if valid

  otherwise, return the given chosenDate, if it is a single date, or
  the first date in the range, if it is a date/daterange array

  otherwise default to the current date

  params:
    viewDate                    the proposed view date to sanitize
    chosenRanges                (optional) either a single date or a
                  list of Date/[Date,Date]  ranges
                  (defaults to this.chosen)
  **/
  CalendarPrototype._sanitizeViewDate = function(viewDate,
    chosenRanges) {
    chosenRanges = (chosenRanges === undefined) ?
      this.chosen : chosenRanges;
    var saneDate;
    // if given a valid viewDate, return it
    if (isValidDateObj(viewDate)) {
      saneDate = viewDate;
    }
    // otherwise if given a single date for chosenRanges, use it
    else if (isValidDateObj(chosenRanges)) {
      saneDate = chosenRanges;
    }
    // otherwise, if given a valid chosenRanges, return the first date in
    // the range as the view date
    else if (isArray(chosenRanges) && chosenRanges.length > 0) {
      var firstRange = chosenRanges[0];
      if (isValidDateObj(firstRange)) {
        saneDate = firstRange;
      } else {
        saneDate = firstRange[0];
      }
    }
    // if not given a valid viewDate or chosenRanges, return the current
    // day as the view date
    else {
      saneDate = TODAY;
    }
    return saneDate;
  };

  /** _collapseRanges: (Date/[Date,Date]) array => (Date/[Date,Date]) array

  given a list of dates/dateranges, nondestructively sort by ascending date,
  then collapse/merge any consecutive dates into date ranges and return the
  resulting list
  **/
  function _collapseRanges(ranges) {
    ranges = ranges.slice(0); // nondestructive sort
    sortRanges(ranges);

    var collapsed = [];
    for (var i = 0; i < ranges.length; i++) {
      var currRange = ranges[i];
      var prevRange = (collapsed.length > 0) ?
        collapsed[collapsed.length - 1] : null;

      var currStart, currEnd;
      var prevStart, prevEnd;

      if (isValidDateObj(currRange)) {
        currStart = currEnd = currRange;
      } else {
        currStart = currRange[0];
        currEnd = currRange[1];
      }
      // collapse extraneous range into a singular date
      currRange = (dateMatches(currStart, currEnd)) ?
        currStart : [currStart, currEnd];

      if (isValidDateObj(prevRange)) {
        prevStart = prevEnd = prevRange;
      } else if (prevRange) {
        prevStart = prevRange[0];
        prevEnd = prevRange[1];
      } else {
        // if no previous range, just add the current range to the list
        collapsed.push(currRange);
        continue;
      }

      // if we should collapse range, merge with previous range
      if (dateMatches(currStart, [prevRange]) ||
        dateMatches(prevDay(currStart), [prevRange])) {

        var minStart = (prevStart.valueOf() < currStart.valueOf()) ?
          prevStart : currStart;
        var maxEnd = (prevEnd.valueOf() > currEnd.valueOf()) ?
          prevEnd : currEnd;

        var newRange = (dateMatches(minStart, maxEnd)) ?
          minStart : [minStart, maxEnd];
        collapsed[collapsed.length - 1] = newRange;
      } else {
        // if we don't collapse, just add to list
        collapsed.push(currRange);
      }
    }
    return collapsed;
  }


  /** Calendar._sanitizeChosenRanges:
      ((Date/[Date,Date]) array, Date) => (Date/[Date,Date]) array

  given a chosen range list or chosen date and an optional view date
  return the range list as the chosen date range,
  depending on what information is given

  if chosenrange is given as a valid date, return it as a singleton list
  if chosenrange is given as a valid date/daterange list, return it

  otherwise, return the given view date in a singleton list, or an empty list
  if the view is invalid or chosen is specifically set to nothing

  params:
    chosenRanges                either a single date or a list of
                  Date/[Date,Date] ranges to sanitize
                  if set to null or undefined, this is
                  interpreted as an empty list

    viewDate                    (optional) the current cursor date
                  (default = this.view)
  **/
  CalendarPrototype._sanitizeChosenRanges = function(chosenRanges,
    viewDate) {
    viewDate = (viewDate === undefined) ? this.view : viewDate;

    var cleanRanges;
    if (isValidDateObj(chosenRanges)) {
      cleanRanges = [chosenRanges];
    } else if (isArray(chosenRanges)) {
      cleanRanges = chosenRanges;
    } else if (chosenRanges === null || chosenRanges === undefined ||
      !viewDate) {
      cleanRanges = [];
    } else {
      cleanRanges = [viewDate];
    }

    var collapsedRanges = _collapseRanges(cleanRanges);
    // if multiple is not active, only get the first date of the chosen
    // ranges for the sanitize range list
    if ((!this.multiple) && collapsedRanges.length > 0) {
      var firstRange = collapsedRanges[0];

      if (isValidDateObj(firstRange)) {
        return [firstRange];
      } else {
        return [firstRange[0]];
      }
    } else {
      return collapsedRanges;
    }
  };


  /** Calendar.addDate: (Date, Boolean)

  if append is falsy/not given, replaces the calendar's chosen ranges with
  the given date

  if append is truthy, adds the given date to the stored list of date ranges
  **/
  CalendarPrototype.addDate = function(dateObj, append) {
    if (isValidDateObj(dateObj)) {
      if (append) {
        this.chosen.push(dateObj);
        // trigger setter
        this.chosen = this.chosen;
      } else {
        this.chosen = [dateObj];
      }
    }
  };

  /** Calendar.removeDate: (Date)

  removes the given date from the Calendar's stored chosen date ranges
  **/
  CalendarPrototype.removeDate = function(dateObj) {
    if (!isValidDateObj(dateObj)) {
      return;
    }
    // search stored chosen ranges for the given date to remove
    var ranges = this.chosen.slice(0);
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      if (dateMatches(dateObj, [range])) {
        // remove the item the date was found in
        ranges.splice(i, 1);

        // if the date was located in a 2-item date range, split the
        // range into separate ranges/dates as needed
        if (isArray(range)) {
          var rangeStart = range[0];
          var rangeEnd = range[1];
          var prevDate = prevDay(dateObj);
          var nextDate = nextDay(dateObj);

          // if we should keep the preceding section of the range
          if (dateMatches(prevDate, [range])) {
            ranges.push([rangeStart, prevDate]);
          }

          // if we should keep the succeeding section of the range
          if (dateMatches(nextDate, [range])) {
            ranges.push([nextDate, rangeEnd]);
          }
        }
        this.chosen = _collapseRanges(ranges);
        break;
      }
    }
  };

  /** Calendar.hasChosenDate: (Date) => Boolean

  returns true if the given date is one of the dates stored as chosen
  **/
  CalendarPrototype.hasChosenDate = function(dateObj) {
    return dateMatches(dateObj, this._chosenRanges);
  };


  /** Calendar.hasVisibleDate: (Date, Boolean)

  if excludeBadMonths is falsy/not given, return true if the given date is
  at all visible in the calendar element, including the remnants of
  months visible on the edges of the current span

  if excludeBadMonths is truthy, return true if the given date is contained
  within the current visible span of dates, ignoring those in months not
  actually within the span
  **/
  CalendarPrototype.hasVisibleDate = function(dateObj, excludeBadMonths) {
    var startDate = (excludeBadMonths) ? this.firstVisibleMonth :
      this.firstVisibleDate;
    var endDate = (excludeBadMonths) ? findLast(this.lastVisibleMonth) :
      this.lastVisibleDate;

    return dateMatches(dateObj, [
      [startDate, endDate]
    ]);
  };


  /** Calendar.render: (Boolean)

  Updates the DOM nodes stored in the current calendar

  if preserveNodes is falsy/not given, removes all existing nodes and
  completely recreates the calendar
     - use this when switching calendar displays, such as when changing span
     or using view to switch months
     - NOTE: throwing away nodes during an event handler kills the
     propagation chain, so account for this

  if preserveNodes is truthy, only update the status/classes of the currently
  displayed day nodes

  NOTE: this doesn't update the navigation controls, as they are separate from
  the calendar element
  **/
  CalendarPrototype.render = function(preserveNodes) {
    var span = this._span;
    var i;
    if (!preserveNodes) {
      this.el.innerHTML = "";
      // get first month of the span of months centered on the view
      var ref = this.firstVisibleMonth;
      for (i = 0; i < span; i++) {
        this.el.appendChild(this.makeMonth(ref));
        // get next month's date
        ref = relOffset(ref, 0, 1, 0);
      }
    }
    // if we want to maintain the original elements without completely
    // wiping and rewriting nodes (ex: when the visible dates don't change)
    else {
      var days = this.el.querySelectorAll(".day");
      var day;
      for (i = 0; i < days.length; i++) {
        day = days[i];

        if (!day.hasAttribute("data-date")) {
          continue;
        }

        var dateIso = day.getAttribute("data-date");
        var parsedDate = fromIso(dateIso);
        if (!parsedDate) {
          continue;
        } else {
          if (dateMatches(parsedDate, this._chosenRanges)) {
            day.classList.add(chosenClass);
          } else {
            day.classList.remove(chosenClass);
          }

          if (dateMatches(parsedDate, [TODAY])) {
            day.classList.add("today");
          } else {
            day.classList.remove("today");
          }
        }
      }
    }

    // finally call the custom renderer
    this._callCustomRenderer();
  };

  // call custom renderer on each day, passing in the element, the
  // date, and the iso representation of the date
  CalendarPrototype._callCustomRenderer = function() {
    if (!this._customRenderFn) {
      return;
    }

    // prevent infinite recursion of custom rendering requiring a rerender
    // of the calendar
    if (this._renderRecursionFlag) {
      throw ("Error: customRenderFn causes recursive loop of " +
        "rendering calendar; make sure your custom rendering " +
        "function doesn't modify attributes of the brick-calendar that " +
        "would require a re-render!");
    }

    var days = this.el.querySelectorAll(".day");
    for (var i = 0; i < days.length; i++) {
      var day = days[i];
      var dateIso = day.getAttribute("data-date");
      var parsedDate = fromIso(dateIso);

      this._renderRecursionFlag = true;
      this._customRenderFn(day, (parsedDate) ? parsedDate : null,
        dateIso);
      this._renderRecursionFlag = false;
    }
  };

  Object.defineProperties(CalendarPrototype, {
    /** Calendar.el: (readonly)

    the DOM element representing the calendar's contianer element

    Note that this is the .calendar child div, NOT the brick-calendar itself!

    (Controls are separated in order to prevent the need for constant
     layout repositioning due to z-indexing)
    **/
    "el": {
      get: function() {
        return this._el;
      }
    },

    /** Calendar.multiple: (read-writeable)

    a boolean value determining if multiple dates can be chosen
    simultaneously
    **/
    "multiple": {
      get: function() {
        return this._multiple;
      },
      set: function(multi) {
        this._multiple = multi;
        this.chosen = this._sanitizeChosenRanges(this.chosen);
        this.render(true);
      }
    },

    /** Calendar.span: (read-writeable)

    the number of months to show in the calendar display
    **/
    "span": {
      get: function() {
        return this._span;
      },
      set: function(newSpan) {
        var parsedSpan = parseIntDec(newSpan);
        if (!isNaN(parsedSpan) && parsedSpan >= 0) {
          this._span = parsedSpan;
        } else {
          this._span = 0;
        }
        this.render(false);
      }
    },

    /** Calendar.view: (read-writeable)

    the cursor date to center the calendar display on
    **/
    "view": {
      attribute: {},
      get: function() {
        return this._viewDate;
      },
      set: function(rawViewDate) {
        var newViewDate = this._sanitizeViewDate(rawViewDate);
        var oldViewDate = this._viewDate;
        this._viewDate = newViewDate;

        this.render(oldViewDate.getMonth() === newViewDate.getMonth() &&
          oldViewDate.getYear() === newViewDate.getYear());
      }
    },

    /** Calendar.chosen: (read-writeable)

    the Date/[Date,Date] array representing the dates currently marked
    as chosen

    setter can take a date or a Date/[Date,Date] array
    (null is interpreted as an empty array)
    **/
    "chosen": {
      get: function() {
        return this._chosenRanges;
      },
      set: function(newChosenRanges) {
        this._chosenRanges =
          this._sanitizeChosenRanges(newChosenRanges);
        this.render(true);
      }
    },

    "firstWeekdayNum": {
      get: function() {
        return this._firstWeekdayNum;
      },
      set: function(weekdayNum) {
        weekdayNum = parseIntDec(weekdayNum);
        if (!isWeekdayNum(weekdayNum)) {
          weekdayNum = 0;
        }
        this._firstWeekdayNum = weekdayNum;
        this.render(false);
      }
    },

    "lastWeekdayNum": {
      get: function() {
        return (this._firstWeekdayNum + 6) % 7;
      }
    },

    /** Calendar.customRenderFn: (read-writable)

    a function taking in a day element, its corresponding Date object,
    and the iso string corresponding to this date
    used to apply any user-defined rendering to the days in the element
    **/
    "customRenderFn": {
      get: function() {
        return this._customRenderFn;
      },
      set: function(newRenderFn) {
        this._customRenderFn = newRenderFn;
        this.render(true);
      }
    },

    /** Calendar.chosenString: (readonly)

    an attribute safe string representing the currently chosen range of
    dates (ie: the JSON string representing it)
    **/
    "chosenString": {
      get: function() {
        if (this.multiple) {
          var isoDates = this.chosen.slice(0);

          for (var i = 0; i < isoDates.length; i++) {
            var range = isoDates[i];
            if (isValidDateObj(range)) {
              isoDates[i] = iso(range);
            } else {
              isoDates[i] = [iso(range[0]), iso(range[1])];
            }
          }
          return JSON.stringify(isoDates);
        } else if (this.chosen.length > 0) {
          return iso(this.chosen[0]);
        } else {
          return "";
        }
      }
    },

    /** Calendar.firstVisibleMonth: (readonly)

    gets the Date of the first day in the
    first month out of those included in the calendar span
    **/
    "firstVisibleMonth": {
      get: function() {
        return findFirst(this.view);
      }
    },

    /** Calendar.lastVisibleMonth: (readonly)

    gets the Date of the first day in the
    last month out of those included in the calendar span
    **/
    "lastVisibleMonth": {
      get: function() {
        return relOffset(this.firstVisibleMonth, 0,
          Math.max(0, this.span - 1), 0);
      }
    },

    "firstVisibleDate": {
      get: function() {
        return findWeekStart(this.firstVisibleMonth,
          this.firstWeekdayNum);
      }
    },

    "lastVisibleDate": {
      get: function() {
        return findWeekEnd(findLast(this.lastVisibleMonth),
          this.lastWeekdayNum);
      }
    },

    "labels": {
      get: function() {
        return this._labels;
      },
      set: function(newLabelData) {
        var oldLabelData = this.labels;
        for (var labelType in oldLabelData) {
          if (!(labelType in newLabelData)) {
            continue;
          }

          var oldLabel = this._labels[labelType];
          var newLabel = newLabelData[labelType];
          // if the old label data used an array of labels for a
          // certain type of label, ensure that
          // the replacement labels are also an array of the same
          // number of labels
          if (isArray(oldLabel)) {
            if (isArray(newLabel) &&
              oldLabel.length === newLabel.length) {
              newLabel = newLabel.slice(0);
              for (var i = 0; i < newLabel.length; i++) {
                // check for existing builtin toString for
                // string casting optimization
                newLabel[i] = (newLabel[i].toString) ?
                  newLabel[i].toString() :
                  String(newLabel[i]);
              }
            } else {
              throw ("invalid label given for '" + labelType +
                "': expected array of " + oldLabel.length +
                " labels, got " + JSON.stringify(newLabel));
            }
          } else {
            newLabel = String(newLabel);
          }
          oldLabelData[labelType] = newLabel;
        }
        this.render(false);
      }
    }
  });

  /** _onDragStart: (brick-calendar DOM, Date)

  when called, sets xCalendar to begin tracking a drag operation

  also toggles the given day if allowed
  **/
  function _onDragStart(xCalendar, day) {
    var isoDate = day.getAttribute("data-date");
    var dateObj = parseSingleDate(isoDate);
    var toggleEventName;
    if (day.classList.contains(chosenClass)) {
      xCalendar.ns.dragType = DRAG_REMOVE;
      toggleEventName = "datetoggleoff";
    } else {
      xCalendar.ns.dragType = DRAG_ADD;
      toggleEventName = "datetoggleon";
    }
    xCalendar.ns.dragStartEl = day;
    xCalendar.ns.dragAllowTap = true;

    if (!xCalendar.noToggle) {
      xCalendar.dispatchEvent(new CustomEvent(toggleEventName, {
        detail: {
          date: dateObj,
          iso: isoDate
        },
        bubbles: true
      }));
    }

    xCalendar.setAttribute("active", true);
    day.setAttribute("active", true);
  }

  /** _onDragMove: (brick-calendar DOM, Date)

  when called, handles toggling behavior for the given day if needed
  when drag-painted over

  sets active attribute for the given day as well, if currently dragging
  **/
  function _onDragMove(xCalendar, day) {
    var isoDate = day.getAttribute("data-date");
    var dateObj = parseSingleDate(isoDate);
    if (day !== xCalendar.ns.dragStartEl) {
      xCalendar.ns.dragAllowTap = false;
    }

    if (!xCalendar.noToggle) {
      // trigger a selection if we enter a nonchosen day while in
      // addition mode
      if (xCalendar.ns.dragType === DRAG_ADD &&
        !(day.classList.contains(chosenClass))) {
        xCalendar.dispatchEvent(new CustomEvent("datetoggleon", {
          detail: {
            date: dateObj,
            iso: isoDate
          },
          bubbles: true
        }));
      }
      // trigger a remove if we enter a chosen day while in
      // removal mode
      else if (xCalendar.ns.dragType === DRAG_REMOVE &&
        day.classList.contains(chosenClass)) {
        xCalendar.dispatchEvent(new CustomEvent("datetoggleoff", {
          detail: {
            date: dateObj,
            iso: isoDate
          }
        }));
      }
    }
    if (xCalendar.ns.dragType) {
      day.setAttribute("active", true);
    }
  }

  /** _onDragEnd

  when called, ends any drag operations of any brick-calendars in the document
  **/
  function _onDragEnd() {
    var xCalendars = document.querySelectorAll("brick-calendar");
    for (var i = 0; i < xCalendars.length; i++) {
      var xCalendar = xCalendars[i];
      xCalendar.ns.dragType = null;
      xCalendar.ns.dragStartEl = null;
      xCalendar.ns.dragAllowTap = false;
      xCalendar.removeAttribute("active");
    }

    var days = document.querySelectorAll("brick-calendar .day[active]");
    for (var j = 0; j < days.length; j++) {
      days[j].removeAttribute("active");
    }
  }

  /* _pointIsInRect: (Number, Number, {left: number, top: number,
                     right: number, bottom: number})
  */
  function _pointIsInRect(x, y, rect) {
    return (rect.left <= x && x <= rect.right &&
      rect.top <= y && y <= rect.bottom);
  }

  // added on the body to delegate dragends to all brick-calendars
  var DOC_MOUSEUP_LISTENER = null;

  function delegate(selector, handler) {
    return function(e) {
      var target = e.target;
      var delegateEl = e.currentTarget;
      var matches = delegateEl.querySelectorAll(selector);
      for (var el = target; el.parentNode && el !== delegateEl; el = el.parentNode) {
        for (var i = 0; i < matches.length; i++) {
          if (matches[i] === el) {
            handler.call(el, e);
            return;
          }
        }
      }
    };
  }

  var BrickCalendarElementPrototype = Object.create(HTMLElement.prototype);

  BrickCalendarElementPrototype.createdCallback = function() {
    this.ns = {};
  };

  BrickCalendarElementPrototype.attachedCallback = function() {

    var importDoc = currentScript.ownerDocument;
    var template = importDoc.querySelector('#brick-calendar-template');

    // fix styling for polyfill
    if (Platform.ShadowCSS) {
      var styles = template.content.querySelectorAll('style');
      for (var i = 0; i < styles.length; i++) {
        var style = styles[i];
        var cssText = Platform.ShadowCSS.shimStyle(style, 'brick-calendar');
        Platform.ShadowCSS.addCssToDocument(cssText);
        style.remove();
      }
    }

    // add calendar before inserting the template
    var chosenRange = this.getAttribute("chosen");
    this.ns.calObj = new Calendar({
      span: this.getAttribute("span"),
      view: parseSingleDate(this.getAttribute("view")),
      chosen: parseMultiDates(chosenRange),
      multiple: this.hasAttribute("multiple"),
      firstWeekdayNum: this.getAttribute("first-weekday-num")
    });
    this.appendChild(this.ns.calObj.el);

    if (this.hasAttribute("controls")) {
      this.controls = true;
    }

    this.ns.calControls = null;

    // used to track if we are currently in a dragging operation,
    // and if so, what type
    this.ns.dragType = null;
    // used to track if we've entered any other elements
    // so that "tap" isn't fired on a drag
    this.ns.dragStartEl = null;
    this.ns.dragAllowTap = false;

    // add the global listeners only once
    if (!DOC_MOUSEUP_LISTENER) {
      DOC_MOUSEUP_LISTENER = document.addEventListener("mouseup", _onDragEnd);
    }
    this.render(false);

    // EventListeners
    this.ns.listeners = {};

    this.ns.listeners.clickNext = delegate(".next", function(e) {
      var xCalendar = e.currentTarget;
      xCalendar.nextMonth();
      xCalendar.dispatchEvent(new CustomEvent("nextmonth", {
        bubbles: true
      }));
    });
    this.addEventListener("click", this.ns.listeners.clickNext);

    this.ns.listeners.clickPrev = delegate(".prev", function(e) {
      var xCalendar = e.currentTarget;
      xCalendar.prevMonth();
      xCalendar.dispatchEvent(new CustomEvent("prevmonth", {
        bubbles: true
      }));
    });
    this.addEventListener("click", this.ns.listeners.clickPrev);

    this.ns.listeners.pointerdownDay = delegate(".day", function(e) {
      // TDOD: FIX THIS
      // prevent firing on right click
      if (e.button && e.button !== LEFT_MOUSE_BTN) {
        return;
      }
      // prevent dragging around existing selections
      // also prevent mobile drag scroll
      e.preventDefault();
      if (e.baseEvent) {
        e.baseEvent.preventDefault();
      }
      _onDragStart(e.currentTarget, this);
    });
    this.addEventListener("mousedown", this.ns.listeners.pointerdownDay);

    // mouse drag move, firing toggles on newly entered dates if needed
    this.ns.listeners.mouseoverDay = delegate(".day", function(e) {
      var xCalendar = e.currentTarget;
      var day = this;

      _onDragMove(xCalendar, day);
    });
    this.addEventListener("mouseover", this.ns.listeners.mouseoverDay);

    this.ns.listeners.mouseoutDay = delegate(".day.", function() {
      var day = this;
      day.removeAttribute("active");
    });
    this.addEventListener("mouseout", this.ns.mouseoutDay);

    this.ns.listeners.pointerupDay = delegate(".day", function(e) {
      var xCalendar = e.currentTarget;

      // make sure that we can actually consider this a tap
      // (note that this delegated version fires before the
      //  mouseup/touchend events we assigned to the document)
      if (!xCalendar.ns.dragAllowTap) {
        return;
      }
      var day = this;
      var isoDate = day.getAttribute("data-date");
      var dateObj = parseSingleDate(isoDate);

      xCalendar.dispatchEvent(new CustomEvent("datetap", {
        detail: {
          date: dateObj,
          iso: isoDate
        },
        bubbles: true
      }));
    });
    this.addEventListener("mouseup", this.ns.listeners.pointerupDay);

    this.ns.listeners.datetoggleon = function(e) {
      var xCalendar = this;
      xCalendar.toggleDateOn(e.detail.date, xCalendar.multiple);
    };
    this.addEventListener("datetoggleon", this.ns.listeners.datetoggleon);

    this.ns.listeners.datetoggleoff = function(e) {
      var xCalendar = this;
      xCalendar.toggleDateOn(e.detail.date, xCalendar.multiple);
    };
    this.addEventListener("datetoggleoff", this.ns.listeners.datetoggleoff);

    // create shadowRoot and append template to it.
    this.shadowRoot = this.createShadowRoot();
    this.shadowRoot.appendChild(template.content.cloneNode(true));

  };

  BrickCalendarElementPrototype.detachedCallback = function() {
    // Cleanup EventListeners
    this.removeEventListener("click", this.ns.listeners.clickNext);
    this.removeEventListener("click", this.ns.listeners.clickPrev);

    // if there are no other canlender instances left,
    // remove the global listener.
    if (document.querySelectorAll("brick-calendar").length === 0) {
      if (DOC_MOUSEUP_LISTENER) {
        document.removeEventListener("mouseup", DOC_MOUSEUP_LISTENER);
        DOC_MOUSEUP_LISTENER = null;
      }
    }
  };

  BrickCalendarElementPrototype.attributeChangedCallback = function(attr, oldVal, newVal) {
    if (attr in attrs) {
      attrs[attr].call(this, oldVal, newVal);
    }
  };

  var attrs = {
    'attr': function(oldVal, newVal) {

    }
  };

  // Custom methods

  // updates the brick-calendar display, recreating nodes if preserveNodes
  // if falsy or not given
  BrickCalendarElementPrototype.render = function(preserveNodes) {
    this.ns.calObj.render(preserveNodes);
  };

  // Go back one month by updating the view attribute of the calendar
  BrickCalendarElementPrototype.prevMonth = function() {
    var calObj = this.ns.calObj;
    calObj.view = prevMonth(calObj.view);
  };

  // Advance one month forward by updating the view attribute
  // of the calendar
  BrickCalendarElementPrototype.nextMonth = function() {
    var calObj = this.ns.calObj;
    calObj.view = nextMonth(calObj.view);
  };

  // sets the given date as chosen, either overriding the current
  // chosen dates if append is falsy or not given, or adding to the
  // list of chosen dates, if append is truthy
  // also updates the chosen attribute of the calendar
  BrickCalendarElementPrototype.toggleDateOn = function(newDateObj, append) {
    this.ns.calObj.addDate(newDateObj, append);
    // trigger setter
    this.chosen = this.chosen;
  };

  // removes the given date from the chosen list
  // also updates the chosen attribute of the calendar
  BrickCalendarElementPrototype.toggleDateOff = function(dateObj) {
    this.ns.calObj.removeDate(dateObj);
    // trigger setter
    this.chosen = this.chosen;
  };

  // switches the chosen status of the given date
  // 'appendIfAdd' specifies how the date is added to the list of
  // chosen dates if toggled on
  // also updates the chosen attribute of the calendar
  BrickCalendarElementPrototype.toggleDate = function(dateObj, appendIfAdd) {
    if (this.ns.calObj.hasChosenDate(dateObj)) {
      this.toggleDateOff(dateObj);
    } else {
      this.toggleDateOn(dateObj, appendIfAdd);
    }
  };

  // returns whether or not the given date is in the visible
  // calendar display, optionally ignoring dates outside of the
  // month span
  BrickCalendarElementPrototype.hasVisibleDate = function(dateObj, excludeBadMonths) {
    return this.ns.calObj.hasVisibleDate(dateObj,
      excludeBadMonths);
  };

  // Property handlers

  Object.defineProperties(BrickCalendarElementPrototype, {
    // handles if the brick-calendar should display navigation controls or
    // not
    // Boolean
    'controls': {
      set: function(newVal) {
        if (newVal && !this.ns.calControls) {
          this.setAttribute("controls", "");
          this.ns.calControls = makeControls(this.ns.calObj.labels);
          this.appendChild(this.ns.calControls);
        }
      }
    },
    // handles if the brick-calendar should allow multiple dates to be
    // chosen at once
    // Boolean
    'multiple': {
      get: function() {
        return this.ns.calObj.multiple;
      },
      set: function(newVal) {
        if (newVal) {
          this.setAttribute("multiple", newVal);
        } else {
          this.removeAttribute("multiple");
        }
        this.ns.calObj.multiple = !!newVal;
      }
    },
    // handles how many months the brick-calendar displays at once
    'span': {
      get: function() {
        return this.ns.calObj.span;
      },
      set: function(newVal) {
        this.ns.calObj.span = newVal;
        this.setAttribute("span", newVal);
      }
    },
    // handles where the brick-calendar's display is focused
    'view': {
      get: function() {
        return this.ns.calObj.view;
      },
      set: function(newVal) {
        var parsedDate = parseSingleDate(newVal);
        if (parsedDate) {
          this.ns.calObj.view = parsedDate;
        }
      }
    },
    // handles which dates are marked as chosen in the brick-calendar
    // setter can take a parseable string, a singular date, or a range
    // of dates/dateranges
    'chosen': {
      get: function() {
        var chosenRanges = this.ns.calObj.chosen;
        // return a single date if multiple selection not allowed
        if (!this.multiple) {
          if (chosenRanges.length > 0) {
            var firstRange = chosenRanges[0];
            if (isValidDateObj(firstRange)) {
              return firstRange;
            } else {
              return firstRange[0];
            }
          } else {
            return null;
          }
        }
        // otherwise return the entire selection list
        else {
          return this.ns.calObj.chosen;
        }
      },
      set: function(newVal) {
        var parsedDateRanges = (this.multiple) ?
          parseMultiDates(newVal) :
          parseSingleDate(newVal);
        if (parsedDateRanges) {
          this.ns.calObj.chosen = parsedDateRanges;
        } else {
          this.ns.calObj.chosen = null;
        }

        if (this.ns.calObj.chosenString) {
          // override attribute with auto-generated string
          this.setAttribute("chosen",
            this.ns.calObj.chosenString);
        } else {
          this.removeAttribute("chosen");
        }
      }
    },
    // handles which day to use as the first day of the week
    'firstWeekdayNum': {
      get: function() {
        return this.getAttribute("first-weekday-num");
      },
      set: function(newVal) {
        this.ns.calObj.firstWeekdayNum = newVal;
        this.setAttribute("first-weekday-num", newVal);
      }
    },
    // handles if the brick-calendar allows dates to be chosen or not
    // ie: if set, overrides default chosen-toggling behavior of the UI
    'noToggle': {
      get: function() {
        return this.hasAttribute("notoggle");
      },
      set: function(newVal) {
        if (newVal) {
          this.chosen = null;
          this.setAttribute("notoggle", "");
        } else {
          this.removeAttribute("notoggle");
        }
      }
    },
    // (readonly) retrieves the first day in the first fully-visible
    // month of the calendar
    'firstVisibleMonth': {
      get: function() {
        return this.ns.calObj.firstVisibleMonth;
      }
    },
    // (readonly) retrieves the first day in the first fully-visible
    // month of the calendar
    'lastVisibleMonth': {
      get: function() {
        return this.ns.calObj.lastVisibleMonth;
      }
    },
    // (readonly) retrieves the first day in the calendar, even if it
    // is not part of a fully visible month
    'firstVisibleDate': {
      get: function() {
        return this.ns.calObj.firstVisibleDate;
      }
    },
    // (readonly) retrieves the last day in the calendar, even if it
    // is not part of a fully visible month
    'lastVisibleDate': {
      get: function() {
        return this.ns.calObj.lastVisibleDate;
      }
    },
    /** a function taking the following parameters:
       - a html element representing a day in the calendar
       - its corresponding Date object
       - the iso string corresponding to this Date

    this custom function is called whenever the calendar needs to be
    rendered, and is used to provide more flexibility in dynamically
    styling days of the calendar

    IMPORTANT NOTE: because this is called whenever the calendar is
    rendered, and because most calendar attribute changes
    **/
    'customRenderFn': {
      get: function() {
        return this.ns.calObj.customRenderFn;
      },
      set: function(newRenderFn) {
        this.ns.calObj.customRenderFn = newRenderFn;
      }
    },
    'labels': {
      get: function() {
        // clone labels to prevent user from clobbering aliases
        return JSON.parse(JSON.stringify(this.ns.calObj.labels));
      },
      // if given a datamap of labels whose keys match those in
      // DEFAULT_LABELS, reassign the labels using those in the given
      // newLabelData. Ensures that labels that were initially strings
      // stay strings, and that labels that were initially arrays of
      // strings stay arrays of strings (with the same # of elements)
      set: function(newLabelData) {
        this.ns.calObj.labels = newLabelData;
        var labels = this.ns.calObj.labels;
        // also update the control labels, if available
        var prevControl = this.querySelector(".controls > .prev");
        if (prevControl) {
          prevControl.textContent = labels.prev;
        }

        var nextControl = this.querySelector(".controls > .next");
        if (nextControl) {
          nextControl.textContent = labels.next;
        }
      }
    }
  });

  // Register the element
  if (!window.BrickCalendar) {
    window.BrickCalendar = document.registerElement('brick-calendar', {
      prototype: BrickCalendarElementPrototype
    });
  }


})();
;
(function () {

  var BrickCardElementPrototype = Object.create(HTMLElement.prototype);

  BrickCardElementPrototype.createdCallback = function () {
    this.ns = {};
  };

  BrickCardElementPrototype.attachedCallback = function () {
    var deck = this.parentNode;
    if (deck.nodeName.toLowerCase() === 'brick-deck') {
      this.ns.deck = deck;
      if (this !== deck.selectedCard && this.selected) {
        deck.showCard(this, {'skipTransition':true});
      }
    }
  };

  BrickCardElementPrototype.detachedCallback = function () {
    var deck = this.ns.deck;
    if (deck) {
      if (this === deck.selectedCard) {
        deck.selectedCard = null;
        deck.removeAttribute('selected-index');
      }
      this.ns.deck = null;
    }
  };

  BrickCardElementPrototype.attributeChangedCallback = function (attr, oldVal, newVal) {
    if (attr in attrs) {
      attrs[attr].call(this, oldVal, newVal);
    }
  };

  // Attribute handlers
  var attrs = {
    'selected': function (oldVal, newVal) {
      var deck = this.ns.deck;
      if (!deck) { return; }
      // check for null because empty string is true
      // for our booleon attribute
      if (newVal !== null) {
        if (this !== deck.selectedCard) { deck.showCard(this); }
      } else {
        if (this === deck.selectedCard) { deck.hideCard(this); }
      }
    },
  };

  BrickCardElementPrototype.reveal = function() {
    this.dispatchEvent(new CustomEvent("reveal",{bubbles: true}));
  };

  // Property handlers
  Object.defineProperties(BrickCardElementPrototype, {
    'selected': {
      get : function () {
        return this.hasAttribute('selected');
      },
      set : function (newVal) {
        if (newVal) {
          this.setAttribute('selected','');
        } else {
          this.removeAttribute('selected');
        }
      }
    },
    'transitionType': {
      get: function() {
        return this.getAttribute("transition-type");
      },
      set: function(newVal) {
        this.setAttribute("transition-type", newVal);
      }
    }
  });

  // Register the element
  if (!window.BrickCardElement) {
    window.BrickCardElement = document.registerElement('brick-card', {
      prototype: BrickCardElementPrototype
    });
  }

})();
;
/* global Platform */
(function () {

  var currentScript = document._currentScript || document.currentScript;

  var requestAnimationFrame = window.requestAnimationFrame ||
                              window.webkitRequestAnimationFrame ||
                              function (fn) { setTimeout(fn, 16); };

  function delegate(selector, handler) {
    return function(e) {
      var target = e.target;
      var delegateEl = e.currentTarget;
      var matches = delegateEl.querySelectorAll(selector);
      for (var el = target; el.parentNode && el !== delegateEl; el = el.parentNode) {
        for (var i = 0; i < matches.length; i++) {
          if (matches[i] === el) {
            handler.call(el, e);
            return;
          }
        }
      }
    };
  }

  var skipFrame = function(fn){
    requestAnimationFrame(function(){ requestAnimationFrame(fn); });
  };

  var sides = {
        next: ['nextElementSibling', 'firstElementChild'],
        previous: ['previousElementSibling', 'lastElementChild']
      };

  function indexOfCard(deck, card){
    return Array.prototype.indexOf.call(deck.children, card);
  }

  function getCard(deck, item){
    if (item && item.nodeName) {
      return item;
    } else {
      if (isNaN(item)) {
        return deck.querySelector(item);
      } else {
        return deck.children[item];
      }
    }
  }


  var card = document.createElement('brick-card');
  //ensure the children is a brick-card (or wraps it with one)
  function ensureIsCard(child){
    if(child.tagName !== 'BRICK-CARD'){
      var wrap = card.cloneNode(),
          attributes = ['selected', 'transition-type'],
          attribute;

      for(var i=0, max=attributes.length; i<max; i++){
        attribute = attributes[i];
        if(child.hasAttribute(attribute)){
          wrap.setAttribute(attribute, child.getAttribute(attribute));
        }
      }
      child.parentNode.replaceChild(wrap, child);
      wrap.appendChild(child);
    }
  }
  // check if a card is a card in a deck
  function checkCard(deck, card){
    return card &&
           deck === card.parentNode &&
           card.nodeName.toLowerCase() === 'brick-card';
  }

  function shuffle(deck, side, direction){
    var getters = sides[side];
    var selected = deck.selectedCard && deck.selectedCard[getters[0]];

    if (selected) {
      deck.showCard(selected, {'direction': direction});
    } else if (deck.loop || deck.selectedIndex === -1) {
      deck.showCard(deck[getters[1]], {'direction': direction});
    }
  }

  var BrickDeckElementPrototype = Object.create(HTMLElement.prototype);

  BrickDeckElementPrototype.createdCallback = function() {
    this.ns = {};
    var children = this.children, i, max, anyChildSelected = false;

    for(i=0, max=children.length; i<max; i++){
      ensureIsCard(children[i]);
      anyChildSelected = anyChildSelected || children[i].hasAttribute('selected');
    }

    var observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        var added = mutation.addedNodes || [];
        for(var i=0, max=added.length; i<max; i++){
          ensureIsCard(added[i]);
        }
      });
    });

    observer.observe(this, { childList: true });
    if(!anyChildSelected){
      this.showCard(this.selectedIndex, {skipTransition:true});
    }
  };

  BrickDeckElementPrototype.attachedCallback = function() {

    var importDoc = currentScript.ownerDocument;
    var template = importDoc.querySelector('#brick-deck-template');

    // fix styling for polyfill
    if (Platform.ShadowCSS) {
      var styles = template.content.querySelectorAll('style');
      for (var i = 0; i < styles.length; i++) {
        var style = styles[i];
        var cssText = Platform.ShadowCSS.shimStyle(style, 'brick-deck');
        Platform.ShadowCSS.addCssToDocument(cssText);
        style.remove();
      }
    }

    // create shadowRoot and append template to it.
    var shadowRoot = this.createShadowRoot();
    shadowRoot.appendChild(template.content.cloneNode(true));

    this.revealHandler = delegate('brick-card', function(e) {
      e.currentTarget.showCard(this);
    });
    this.addEventListener('reveal', this.revealHandler);
  };

  BrickDeckElementPrototype.detachedCallback = function() {
    this.removeEventListener('reveal', this.revealHandler);
  };

  BrickDeckElementPrototype.attributeChangedCallback = function (attr, oldVal, newVal) {
    if (attr in attrs) {
      attrs[attr].call(this, oldVal, newVal);
    }
  };

  var attrs = {
    'selected-index': function (oldVal, newVal) {
      var index = parseInt(newVal);
      if (!isNaN(index)  && this.cards[index] !== this.selectedCard) {
        this.showCard(index);
      }
    }
  };

  BrickDeckElementPrototype.nextCard = function(direction){
    shuffle(this, 'next', direction);
  };

  BrickDeckElementPrototype.previousCard = function(direction){
    shuffle(this, 'previous', direction);
  };

  BrickDeckElementPrototype.showCard = function(item, options){
    options = options || {};
    var direction = options.direction;
    var skipTransition = options.skipTransition;
    var card = getCard(this, item);
    if (!checkCard(this, card) || (card === this.selectedCard)) {
      return;
    }
    var selectedCard = this.ns.selectedCard;
    var currentIndex = indexOfCard(this, selectedCard);
    var nextIndex = indexOfCard(this, card);
    if (!direction) {
      direction = nextIndex > currentIndex ? 'forward' : 'reverse';
      // if looping is turned on, check if the other way round is shorter
      if (this.loop) {
        // the distance between two cards
        var dist = nextIndex - currentIndex;
        // the distance between two cards when skipping over the end of the deck
        var distLooped = this.cards.length - Math.max(nextIndex,currentIndex) + Math.min(nextIndex,currentIndex);
        // set the direction if the looped way is shorter
        if (Math.abs(distLooped) < Math.abs(dist)) {
          direction = nextIndex < currentIndex ? 'forward' : 'reverse';
        }
      }
    }
    // hide the old card
    if (selectedCard) { this.hideCard(selectedCard, direction); }
    this.ns.selectedCard = card;
    this.ns.selectedIndex = nextIndex;
    this.setAttribute("selected-index", nextIndex);
    if (!card.selected) { card.selected = true; }
    card.removeAttribute("hide"); // be safe
    var hasTransition = card.hasAttribute('transition-type') || this.hasAttribute('transition-type');
    if (!skipTransition && hasTransition) {
      // set attributes, set transitionend listener, skip a frame set transition attribute
      card.setAttribute('transition-direction', direction);
      var transitionendHandler = function() {
        card.dispatchEvent(new CustomEvent('show',{'bubbles': true}));
        card.removeEventListener('transitionend', transitionendHandler);
      };
      card.addEventListener('transitionend', transitionendHandler);
      skipFrame(function(){ card.setAttribute('transition', ''); });
    } else {
      card.dispatchEvent(new CustomEvent('show',{'bubbles': true}));
      if (hasTransition) {
        card.setAttribute('transition', '');
      }
    }
  };

  BrickDeckElementPrototype.hideCard = function(item, direction){
    var card = getCard(this, item);
    if (!checkCard(this, card) || (card !== this.selectedCard)) {
      return;
    }
    this.ns.selectedCard = null;
    if (card.selected) { card.selected = false; }
    var hasTransition = card.hasAttribute('transition-type') || this.hasAttribute('transition-type');
    if (hasTransition) {
      // set attributes, set transitionend listener, skip a frame set transition attribute
      var transitionendHandler = function() {
        card.removeAttribute('hide');
        card.removeAttribute('transition');
        card.removeAttribute('transition-direction');
        card.dispatchEvent(new CustomEvent('hide',{'bubbles': true}));
        card.removeEventListener('transitionend', transitionendHandler);
      };
      card.addEventListener('transitionend', transitionendHandler);
      skipFrame(function(){
        card.setAttribute('transition-direction', direction || 'reverse');
        card.setAttribute('hide', '');
      });
    } else {
      card.dispatchEvent(new CustomEvent('hide',{'bubbles': true}));
    }
  };


  // Property handlers
  Object.defineProperties(BrickDeckElementPrototype, {
    'loop': {
      get: function() {
        return this.hasAttribute('loop');
      },
      set: function(newVal) {
        if (newVal) {
          this.setAttribute('loop', newVal);
        } else {
          this.removeAttribute('loop');
        }
      }
    },
    'cards': {
      get: function () {
        var cardList = this.querySelectorAll("brick-card");
        return Array.prototype.slice.call(cardList);
      }
    },
    'selectedCard': {
      get: function() {
        return this.ns.selectedCard || null;
      }
    },
    'selectedIndex': {
      get: function() {
        return this.hasAttribute('selected-index') ? Number(this.getAttribute('selected-index')) : -1;
      },
      set: function(value) {
        var index = Number(value);
        var card = this.cards[index];
        if (card) {
          if (card !== this.ns.selectedCard) {
            this.showCard(card);
          }
        } else {
          this.removeAttribute('selected-index');
          if (this.ns.selectedCard) {
            this.hideCard(this.ns.selectedCard);
          }
        }
      }
    },
    'transitionType': {
      get: function() {
        return this.getAttribute('transition-type');
      },
      set: function(newVal) {
        this.setAttribute('transition-type', newVal);
      }
    }
  });

  // Register the element
  if (!window.BrickDeckElement) {
    window.BrickDeckElement = document.registerElement('brick-deck', {
      prototype: BrickDeckElementPrototype
    });
  }

})();
;
/* globals Platform */

(function () {

  var currentScript = document._currentScript || document.currentScript;

  var requestAnimationFrame = window.requestAnimationFrame ||
                              window.webkitRequestAnimationFrame ||
                              function (fn) { setTimeout(fn, 16); };

  var skipFrame = function(fn){
    requestAnimationFrame(function(){ requestAnimationFrame(fn); });
  };

  var BrickDialogElementPrototype = Object.create(HTMLElement.prototype);

  BrickDialogElementPrototype.attachedCallback = function() {

    var importDoc = currentScript.ownerDocument;
    var template = importDoc.querySelector('#brick-dialog-template');

    // fix styling for polyfill
    if (Platform.ShadowCSS) {
      var styles = template.content.querySelectorAll('style');
      for (var i = 0; i < styles.length; i++) {
        var style = styles[i];
        var cssText = Platform.ShadowCSS.shimStyle(style, 'brick-dialog');
        Platform.ShadowCSS.addCssToDocument(cssText);
        style.remove();
      }
    }

    // create shadowRoot and append template to it.
    var shadowRoot = this.createShadowRoot();
    shadowRoot.appendChild(template.content.cloneNode(true));

    
    this.addEventListener('click', this.hide.bind(this));

    var dialog = shadowRoot.querySelector('.dialog');
    dialog.addEventListener('click', function(e) {
      e.stopPropagation();
    });

  };

  BrickDialogElementPrototype.detachedCallback = function() {
    this.removeEventListener('click', this.hide.bind(this));
  };



  BrickDialogElementPrototype.show = function() {
    var dialog = this;
    dialog.setAttribute('show','');

    skipFrame(function() {
      dialog.setAttribute('show', 'in');
    });
  };

  BrickDialogElementPrototype.hide = function() {
    var dialog = this;
    dialog.setAttribute('show', 'out');

    var animationendHandler = function() {
      dialog.removeAttribute('show');
      dialog.removeEventListener('animationend', animationendHandler);
      dialog.removeEventListener('webkitAnimationEnd', animationendHandler);
    };

    dialog.addEventListener('animationend', animationendHandler);
    dialog.addEventListener('webkitAnimationEnd', animationendHandler);
  };

  // Register the element
  window.BrickDialogElement = document.registerElement('brick-dialog', {
    prototype: BrickDialogElementPrototype
  });

})();
;
/* global Platform */

(function () {

  var currentScript = document._currentScript || document.currentScript;

  var requestAnimationFrame = window.requestAnimationFrame ||
                              window.webkitRequestAnimationFrame ||
                              function (fn) { setTimeout(fn, 16); };

  function delegate(selector, handler) {
    return function(e) {
      var target = e.target;
      var delegateEl = e.currentTarget;
      var matches = delegateEl.querySelectorAll(selector);
      for (var el = target; el.parentNode && el !== delegateEl; el = el.parentNode) {
        for (var i = 0; i < matches.length; i++) {
          if (matches[i] === el) {
            handler.call(el, e);
            return;
          }
        }
      }
    };
  }

  var skipTransition = function(element, fn, bind){
    element.style.webkitTransitionProperty = 'none';
    element.style.transitionProperty = 'none';
    var callback = fn ? fn.call(bind) : null;
    return requestAnimationFrame(function(){
      requestAnimationFrame(function(){
        element.style.webkitTransitionProperty = '';
        element.style.transitionProperty = '';
        if (callback) {
          requestAnimationFrame(callback);
        }
      });
    });
  };

  function reveal(e) {
    var flipBox = e.currentTarget;
    if (this.parentNode === flipBox) {
      if (this.parentNode.firstElementChild === this) {
        flipBox.showFront();
      }
      else if (this.parentNode.lastElementChild === this) {
        flipBox.showBack();
      }
    }
  }

  var BrickFlipboxElementPrototype = Object.create(HTMLElement.prototype);

  BrickFlipboxElementPrototype.attachedCallback = function () {

    var importDoc = currentScript.ownerDocument;
    var template = importDoc.querySelector('#brick-flipbox-template');

    // fix styling for polyfill
    if (Platform.ShadowCSS) {
      var styles = template.content.querySelectorAll('style');
      for (var i = 0; i < styles.length; i++) {
        var style = styles[i];
        var cssText = Platform.ShadowCSS.shimStyle(style, 'brick-flipbox');
        Platform.ShadowCSS.addCssToDocument(cssText);
        style.remove();
      }
    }

    // create shadowRoot and append template to it.
    var shadowRoot = this.createShadowRoot();
    shadowRoot.appendChild(template.content.cloneNode(true));

    // reveal a side when reveal a reveal event is triggered on it.
    this.revealEventHandler = delegate("x-flipbox > *", reveal);
    this.addEventListener("reveal", this.revealEventHandler);

    // default to right.
    var direction = this.getAttribute('direction') || 'right';
    this.direction = direction;
    // instantiate sides without initial flip animation
    if (this.firstElementChild) {
      skipTransition(this.firstElementChild, function () {});
      // fire an flipend Event when the transition ended.
      // only on the first child do avoid firing twice
      this.transitionendEventHandler = function(e) {
        var flipBox = e.target.parentNode;
        var event = new CustomEvent('flipend', {'bubbles': true});
        flipBox.dispatchEvent(event);
        e.stopPropagation();
      };
      this.firstElementChild.addEventListener('transitionend', this.transitionendEventHandler);
    }
    if (this.lastElementChild) {
      skipTransition(this.lastElementChild, function () {});
    }
  };

  BrickFlipboxElementPrototype.detachedCallback = function () {
    // cleanup event listeners
    this.removeEventListener('reveal',this.revealEventHandler);
    if (this.firstElementChild && this.transitionendEventHandler) {
      this.firstElementChild.removeEventListener('transitionend',this.transitionendEventHandler);
    }
  };

  BrickFlipboxElementPrototype.attributeChangedCallback = function (attr, oldVal, newVal) {
    if (attr in attrs) {
      attrs[attr].call(this, oldVal, newVal);
    }
  };

  // Attribute handlers
  var attrs = {
    'direction': function (oldVal, newVal) {
      // Use the setter to update the _anim-direction as well.
      this.direction = newVal;
    }
  };

  // Custom methods
  BrickFlipboxElementPrototype.toggle = function() {
    var newFlippedState = !this.hasAttribute('flipped');
    if (newFlippedState) {
      this.setAttribute('flipped','');
    } else {
      this.removeAttribute('flipped');
    }
  };

  BrickFlipboxElementPrototype.showFront = function() {
    this.removeAttribute('flipped');
  };

  BrickFlipboxElementPrototype.showBack = function() {
    this.setAttribute ('flipped','');
  };

  // Property handlers
  Object.defineProperties(BrickFlipboxElementPrototype, {

    'flipped': {
      // The flipped state is only represented in the flipped attribute.
      get: function() {
        return this.hasAttribute('flipped');
      },
      set: function(newVal) {
        if (newVal) {
          this.setAttribute('flipped', newVal);
        } else {
          this.removeAttribute('flipped');
        }
      }
    },

    'direction': {
      get: function() {
        return this.getAttribute('direction');
      },
      set: function(newVal) {
        var self = this;
        // update the attribute if needed.
        if (self.setAttribute !== newVal) {
          self.setAttribute('direction', newVal);
        }
        // do skipTransition before setting the direction
        // with bot sides if we have sides.
        if (self.firstElementChild) {
          skipTransition(this.firstElementChild, function () {
            self.setAttribute('_anim-direction', newVal);
          });
          skipTransition(this.lastElementChild, function () {});
        } else {
          self.setAttribute('_anim-direction', newVal);
        }
      }
    }

  });

  // Register the element
  if (!window.BrickFlipboxElement) {
    window.BrickFlipboxElement = document.registerElement('brick-flipbox', {
      prototype: BrickFlipboxElementPrototype
    });
  }

})();
;
(function () {
  var BrickFormElementPrototype = Object.create(HTMLElement.prototype);

  BrickFormElementPrototype.attachedCallback = function () {
    var self = this;

    // wrap everuthing inside a form
    self.form = document.createElement('form');

    var children = Array.prototype.slice.call(self.childNodes);
    for (var i = 0; i < children.length; i++) {
      self.form.appendChild(children[i]);
    }
    self.appendChild(self.form);

    if (self.autosave) {
      self.form.addEventListener("change", function(){
        self.saveFormData();
      });
    }

    self.form.addEventListener("submit", function(e){
      e.preventDefault();
      self.saveFormData();
    });

    self.loadFormData();
  };

  BrickFormElementPrototype.attributeChangedCallback = function (attr, oldVal, newVal) {
    if (attr === 'name') {
      if (newVal) {
        this.loadFormData();
      }
    }
  };

  BrickFormElementPrototype.loadFormData = function () {
    var self = this;
    if (!self.name) {
      return;
    }
    self.storage.get(self.name).then(function(data){
      for (var i = 0; i < self.elements.length; i++) {
        var element = self.elements[i];
        if (element.name) {
          var val = data ? data[element.name] || "" : "";
          if (element.type === "checkbox") {
            element.checked = !!val;
          } else {
            element.value = val;
          }
        }
      }
    });
  };

  BrickFormElementPrototype.saveFormData = function () {
    var self = this;
    var data = {};
    if (!self.name) {
      return;
    }
    data[self.keyname] = self.name;
    for (var i = 0; i < self.elements.length; i++) {
      var input = self.elements[i];
      if (input.name) {
        var key = input.name;
        var value = input.value;
        if (input.type === "checkbox") {
          value = input.checked;
        }
        data[key] = value;
      }
    }
    return self.storage.set(data);
  };

  // Property handlers
  Object.defineProperties(BrickFormElementPrototype, {
    'name': {
      get: function () {
        return this.getAttribute("name");
      },
      set: function (newVal) {
        this.setAttribute("name", newVal);
      }
    },
    'autosave': {
      get: function () {
        return this.hasAttribute("autosave");
      },
      set: function (newVal) {
        if (newVal) {
          this.setAttribute("autosave", newVal);
        } else {
          this.removeAttribute("autosave");
        }
      }
    },
    'storage': {
      get: function () {
        return document.getElementById(this.getAttribute("storage"));
      }
    },
    'elements': {
      get: function() {
        return this.querySelectorAll("input, select, textarea");
      }
    },
    'keyname': {
      get: function() {
        return this.storage.getAttribute("keyname");
      }
    }
  });

  // Register the element
  if (!window.BrickFormElement) {
    window.BrickFormElement = document.registerElement('brick-form', {
      prototype: BrickFormElementPrototype
    });
  }

})();
;
/* globals Platform */

(function() {

  var currentScript = document._currentScript || document.currentScript;

  function shimShadowStyles(styles, tag) {
    if (!Platform.ShadowCSS) {
      return;
    }
    for (var i = 0; i < styles.length; i++) {
      var style = styles[i];
      var cssText = Platform.ShadowCSS.shimStyle(style, tag);
      Platform.ShadowCSS.addCssToDocument(cssText);
      style.remove();
    }
  }

  function copyAttributes(src, dest, exceptions) {
    var attrs = src.attributes;
    for (var i = 0; i < attrs.length; i++) {
      var attr = src.attributes[i];
      if (exceptions.indexOf(attr.name) === -1) {
        dest.setAttribute(attr.name, attr.value);
      }
    }
  }

  function addListener(arr, el, event, handler, capture) {
    el.addEventListener(event, handler, capture);
    arr.push([el, event, handler, capture]);
  }
  function removeListener(el, event, handler, capture) {
    el.removeEventListener(event, handler, capture);
  }


  var BrickInputElementPrototype = Object.create(HTMLElement.prototype);

  BrickInputElementPrototype.createdCallback = function () {

  };

  BrickInputElementPrototype.attachedCallback = function () {
    var brickInput = this;
    brickInput.listeners = [];

    // import template
    var importDoc = currentScript.ownerDocument;
    var templateContent = importDoc.querySelector('#brick-input-template').content;

    // fix styling for polyfill
    shimShadowStyles(templateContent.querySelectorAll('style'), 'brick-input');

    // create shadowRoot and append template
    var shadowRoot = brickInput.createShadowRoot();
    shadowRoot.appendChild(templateContent.cloneNode(true));

    // get the input
    if (brickInput.hasAttribute('multiline')) {
      brickInput.input = document.createElement('textarea');
    } else {
      brickInput.input = document.createElement('input');
    }
    copyAttributes(brickInput,brickInput.input,['label', 'multiline']);
    brickInput.appendChild(brickInput.input);
    var inputChangeListener = function () {
      if(!brickInput.input.checkValidity()) {
        brickInput.setAttribute('invalid', '');
      } else {
        brickInput.removeAttribute('invalid');
      }
    };
    addListener(brickInput.listeners, brickInput, 'change', inputChangeListener);

    // setup label
    var placeholderText = brickInput.getAttribute('placeholder');
    var labelText = brickInput.getAttribute('label');
    if (labelText) {
      var label = shadowRoot.querySelector('.label');
      label.appendChild(document.createTextNode(labelText));
    }
    var ariaLabel = labelText || placeholderText;
    if (ariaLabel) {
      brickInput.input.setAttribute('aria-label', labelText);
    }

    // setup error message
    var errorText = brickInput.getAttribute('error');
    if (errorText) {
      var error = shadowRoot.querySelector('.error');
      error.appendChild(document.createTextNode(errorText));
    }

    // setup clear button and listen to it
    var clearButton = shadowRoot.querySelector('.clear');
    brickInput.clearing = false;
    clearButton.addEventListener('click', function () {
      brickInput.input.value = '';
      brickInput.input.focus();
    });
    var clearMouseDownListener = function () {
      brickInput.clearing = true;
    };
    addListener(brickInput.listeners, clearButton, 'mousedown', clearMouseDownListener);
    var clearMouseUpListener = function () {
      brickInput.clearing = false;
    };
    addListener(brickInput.listeners, clearButton, 'mouseup', clearMouseUpListener);

    // listen to focus and blur
    var focusListener = function () {
      brickInput.setAttribute('focus', '');
    };
    addListener(brickInput.listeners, brickInput.input, 'focus', focusListener);
    var blurListener =function () {
      if (!brickInput.clearing) {
        brickInput.removeAttribute('focus');
      }
    };
    addListener(brickInput.listeners, brickInput.input, 'blur', blurListener);
  };

  BrickInputElementPrototype.detachedCallback = function () {
    // clean up listeners
    while(this.listeners.length) {
      removeListener.apply(this, this.listeners.shift());
    }
  };

  BrickInputElementPrototype.attributeChangedCallback = function (attr, oldVal, newVal) {
    if (attr in attrs) {
      attrs[attr].call(this, oldVal, newVal);
    }
  };

  // Attribute handlers
  var attrs = {

  };

  // Property handlers
  Object.defineProperties(BrickInputElementPrototype, {

  });

  // Register the element
  if (!window.BrickInputElement) {
    window.BrickInputElement = document.registerElement('brick-input', {
      prototype: BrickInputElementPrototype
    });
  }

})();
;
/* global Platform */

(function () {

  var currentScript = document._currentScript || document.currentScript;

  var BrickLayoutElementPrototype = Object.create(HTMLElement.prototype);

  BrickLayoutElementPrototype.openDrawer = function() {
    this.setAttribute("open","");
  };
  BrickLayoutElementPrototype.closeDrawer = function() {
    this.removeAttribute("open");
  };
  BrickLayoutElementPrototype.toggleDrawer = function() {
    if (this.hasAttribute("open")) {
      this.removeAttribute("open");
    } else {
      this.setAttribute("open","");
    }
  };

  BrickLayoutElementPrototype.attachedCallback = function() {
    var importDoc = currentScript.ownerDocument;
    var template = importDoc.querySelector('#brick-layout-template');

    // fix styling for polyfill
    if (Platform.ShadowCSS) {
      var styles = template.content.querySelectorAll('style');
      for (var i = 0; i < styles.length; i++) {
        var style = styles[i];
        var cssText = Platform.ShadowCSS.shimStyle(style, 'brick-layout');
        Platform.ShadowCSS.addCssToDocument(cssText);
        style.remove();
      }
    }

    // create shadowRoot and append template to it.
    var shadowRoot = this.createShadowRoot();
    shadowRoot.appendChild(template.content.cloneNode(true));
  };
  if (!window.BrickLayoutElement) {
    window.BrickLayoutElement = document.registerElement('brick-layout', {
      prototype: BrickLayoutElementPrototype
    });
  }

})();
;
/* global Platform, Promise*/

(function () {

  var SCROLL_TIMEOUT = 100;

  var currentScript = document._currentScript || document.currentScript;

  var requestAnimationFrame = window.requestAnimationFrame ||
                              window.mozRequestAnimationFrame ||
                              window.webkitRequestAnimationFrame ||
                              window.msRequestAnimationFrame ||
                              function (fn) { setTimeout(fn, 16); };

  var cancelAnimationFrame = window.cancelAnimationFrame ||
                             window.mozCancelAnimationFrame ||
                             window.webkitCancelAnimationFrame ||
                             window.msCancelAnimationFrame ||
                             function () {};

  var webComponentsReady = new Promise(function (resolve) {
    window.addEventListener('WebComponentsReady', resolve);
  });

  function ArrayAdapter(array) {

    this.array = array;

    this.size = function () {
      return Promise.resolve(array.length);
    };

    this.getMany = function (options) {
      options = options || {};
      var start = options.offset || 0;
      var end = options.count ? options.count + start + 1: undefined;
      return Promise.resolve(array.slice(start, end));
    };

  }

  function shimShadowStyles(styles, tag) {
    if (!Platform.ShadowCSS) {
      return;
    }
    for (var i = 0; i < styles.length; i++) {
      var style = styles[i];
      var cssText = Platform.ShadowCSS.shimStyle(style, tag);
      Platform.ShadowCSS.addCssToDocument(cssText);
      style.remove();
    }
  }

  function computeMetrics(listview) {
    listview.ns.numItemsVisible = (listview.offsetHeight / listview.ns.height|0) + 1;
  }

  function init(listview) {
    var ns = listview.ns;
    var data = ns.data;
    if (!data) {
      return Promise.resolve(listview);
    }
    // create a hidden item to measure its height
    ns.list.innerHTML = '<div class="item sentinel">test</div>';
    return data.size().then(function (numItems) {
      // A list of created, not-in-use DOM nodes
      ns.deadPool = [];
      // Object key to use for display label;
      ns.labelKey = listview.getAttribute('label');
      ns.imageKey = listview.getAttribute('image');
      ns.detailKey = listview.getAttribute('detail');
      // The indexes of the items currently rendered
      ns.visibleItems = [];
      // A lookup cache by index of items from ns.data
      ns.items = {};
      ns.numItems = numItems;
      // A list of open requests for ranges of data
      ns.rangeRequests = [];
      ns.height = listview.querySelector('.sentinel').offsetHeight;
      // Set the height of the scrolling strip
      ns.list.style.height = ns.height * (numItems) + 'px';
      return listview;
    });
  }

  function defaultRenderer(el, row, listview) {
    el.innerHTML = "";
    var labelKey = listview.ns.labelKey;
    var imageKey = listview.ns.imageKey;
    var detailKey = listview.ns.detailKey;

    // the image
    if (imageKey) {
      var img = document.createElement('img');
      img.src = row[listview.getAttribute(imageKey)];
      el.appendChild(img);
    }

    // the content
    var content = document.createElement('div');
    content.classList.add('content');

    if (labelKey) {
      var label = document.createElement('div');
      label.textContent = row[labelKey];
      content.appendChild(label);
    }
    if (detailKey) {
      var detail = document.createElement('div');
      detail.textContent = row[detailKey];
      content.appendChild(detail);
    }
    if (content.hasChildNodes()) {
      el.appendChild(content);
    }
  }

  function placeItem(listview, i) {
    var div;
    var deadPool = listview.ns.deadPool;
    if (deadPool.length) {
      div = deadPool.pop();
      div.innerHTML = '';
    } else {
      div = document.createElement('div');
      div.classList.add('item');
    }
    // place the element along the scroll strip.
    div.style.transform = 'translateY(' + i * 100 + '%)';
    div.style.webkitTransform = 'translateY(' + i * 100 + '%)';
    return div;
  }

  function stopScrolling(listview) {
    listview.classList.remove('scrolling');
  }

  function renderItems(min, rows) {
    var listview = this;
    var ns = listview.ns;
    var items = ns.items;
    for (var i = 0; i < rows.length; i++) {
      if (items[i+min]) {
        items[i+min].__item__ = rows[i];
        renderItem(items[i+min], rows[i], listview);
      }
    }
  }

  function renderItem(el, row, listview) {
    defaultRenderer(el, row, listview);
  }

  function removeReq(requests, min, max) {
    for (var i = 0; i < requests.length; i++) {
      var req = requests[i];
      if (req.min === min && req.max === max) {
        requests.splice(i, 1);
        i--;
      }
    }
  }

  function fetchRange(listview, min, max) {
    var rangeRequests = listview.ns.rangeRequests;
    var realMin = min;
    var realMax = max;
    var data = listview.ns.data;

    rangeRequests.forEach(function (range) {
      if ((range.max > realMin && range.max < realMax) !== (range.min > realMin && range.min < realMax)) {
        if (range.max >= realMin && range.max < realMax) {
          realMin = range.max + 1;
        }
        if (range.min <= realMax && range.min > realMin) {
          realMax = range.min - 1;
        }
      }
    });
    var req = data.getMany({offset: realMin, count: realMax-realMin+1});

    rangeRequests.push({
      min: realMin,
      max: realMax,
      request: req
    });

    req.then(function (rows) {
      renderItems.call(listview, realMin, rows);
    });

    req.then(function () {
      removeReq(rangeRequests, realMin, realMax);
    },function () {
      removeReq(rangeRequests, realMin, realMax);
    });
  }

  function render(listview) {
    var ns = listview.ns;
    ns.skippedFrames = 0;
    var itemWindow = ns.numItemsVisible;
    if (!itemWindow) {
      computeMetrics(listview);
      itemWindow = ns.numItemsVisible;
    }
    var list = ns.list;
    var items = ns.items;
    var visibleItems = ns.visibleItems || [];
    var deadPool = ns.deadPool;
    var height = ns.height;
    var min = Math.max((listview.scrollTop / height|0) - itemWindow * 2, 0);
    var max = Math.min((listview.scrollTop / height|0) + itemWindow * 3, ns.numItems-1);

    var realMin = Infinity;
    var realMax = -Infinity;
    var numToFetch = 0;

    // is this item already rendered?
    for (var i = min; i <= max; i++) {
      if (!items[i]) {

        numToFetch++;

        // if not, create a new item and position it
        var newEl = placeItem(listview, i);
        items[i] = newEl;
        visibleItems.push(i);
        if (!newEl.parentNode) {
          list.appendChild(newEl);
        }

        // adjust the range of data we need to fetch
        realMin = Math.min(i, realMin);
        realMax = Math.max(i, realMax);
      }
    }

    // do we need to fetch data?
    if (numToFetch > 0) {
      fetchRange(listview, realMin, realMax);
    }

    for (i = 0; i < visibleItems.length; i++) {
      var idx = visibleItems[i];
      if (idx < min || idx > max) {
        deadPool.push(items[idx]);
        visibleItems.splice(i,1);
        delete items[idx];
        i--;
      }
    }
  }

  function scroll(listview) {
    if (!listview.ns.data) {
      return;
    }

    var ns = listview.ns;

    if (!ns.numItems) {
      return;
    }

    if (!ns.scrolling) {
      listview.classList.add('scrolling');
      ns.scrolling = true;
    }
    if (ns.scrollTimeout) {
      clearTimeout(ns.scrollTimeout);
    }
    ns.scrollTimeout = setTimeout(function () {
      ns.scrolling = false;
      stopScrolling(listview);
    }, SCROLL_TIMEOUT);

    if (ns.nextFrame) {
      ns.skippedFrames = ns.skippedFrames + 1;
      cancelAnimationFrame(ns.nextFrame);
      ns.nextFrame = null;
    }
    ns.nextFrame = requestAnimationFrame(function () {
      render(listview);
    });
  }

  function clickHandler(e) {
    if ('__item__' in e.target) {
      var ev = new CustomEvent("select", {"detail": e.target.__item__});
      this.dispatchEvent(ev);
    }
  }

  var ListViewPrototype = Object.create(HTMLElement.prototype);

  ListViewPrototype.createdCallback = function () {
    this.ns = {};
    var list = document.createElement('div');
    list.classList.add('list');
    this.ns.list = list;
    this.appendChild(list);
  };

  ListViewPrototype.attachedCallback = function () {
    var listview = this;

    webComponentsReady.then(function() {

      // get the storage
      var storage = listview.getAttribute('storage');
      if (storage) {
        storage = document.getElementById(storage);
        if (storage) {
          listview.ns.data = storage;
        }
      }

      // import template
      var importDoc = currentScript.ownerDocument;
      var templateContent = importDoc.querySelector('#brick-listview-template').content;

      // fix styling for polyfill
      shimShadowStyles(templateContent.querySelectorAll('style'), 'brick-listview');

      // create shadowRoot and append template
      var shadowRoot = listview.createShadowRoot();
      shadowRoot.appendChild(templateContent.cloneNode(true));

      // setup event handlers
      listview.ns.scrollHandler = listview.addEventListener('scroll', function() {
        scroll(listview);
      });
      listview.ns.clickHandler = listview.addEventListener('click', clickHandler.bind(listview));

      // render the list
      listview.render();

    });
  };

  ListViewPrototype.detachedCallback = function () {
    var listview = this;
    listview.removeEventListener('scroll', listview.ns.scrollHandler);
    listview.removeEventListener('click', listview.ns.clickHandler);
  };

  var attrs = {
    'storage': function (oldVal, newVal) {
      this.ns.storage = document.getElementById(newVal);
      this.render();
    },
    'label': function () {
      this.render();
    },
    'detail': function () {
      this.render();
    },
    'image': function () {
      this.render();
    }
  };

  ListViewPrototype.attributeChangedCallback = function (attr, oldVal, newVal) {
    if (attr in attrs) {
      attrs[attr].call(this, oldVal, newVal);
    }
  };

  ListViewPrototype.render = function () {
    init(this).then(render);
  };

  Object.defineProperties (ListViewPrototype, {
    'data': {
      get: function () {
        // return either the array or the store
        return this.ns.data.array || this.ns.data;
      },
      set: function (newVal) {
        if (Array.isArray(newVal)) {
          this.ns.data = new ArrayAdapter(newVal);
        } else {
          this.ns.data = newVal;
        }
        this.render();
      }
    }
  });

  window.BrickListViewElement = document.registerElement('brick-listview', {
    prototype: ListViewPrototype
  });

})();
;
/* globals Platform */

(function () {

  var currentScript = document._currentScript || document.currentScript;

  var BrickMenuElementPrototype = Object.create(HTMLElement.prototype);

  BrickMenuElementPrototype.attachedCallback = function() {

    var importDoc = currentScript.ownerDocument;
    var template = importDoc.querySelector('#brick-menu-template');

    // fix styling for polyfill
    if (Platform.ShadowCSS) {
      var styles = template.content.querySelectorAll('style');
      for (var i = 0; i < styles.length; i++) {
        var style = styles[i];
        var cssText = Platform.ShadowCSS.shimStyle(style, 'brick-menu');
        Platform.ShadowCSS.addCssToDocument(cssText);
        style.remove();
      }
    }

    // create shadowRoot and append template to it.
    var shadowRoot = this.createShadowRoot();
    shadowRoot.appendChild(template.content.cloneNode(true));

  };

  // Register the element
  if (!window.BrickMenuElement) {
    window.BrickMenuElement = document.registerElement('brick-menu', {
      prototype: BrickMenuElementPrototype
    });
  }

})();
;
(function() {

  var KEYVALUE_API_VERSION = 1;

  var indexedDB = window.indexedDB ||
                  window.mozIndexedDB ||
                  window.webkitIndexedDB ||
                  window.msIndexedDB;

  var IDBKeyRange = window.IDBKeyRange ||
                    window.webkitIDBKeyRange ||
                    window.msIDBKeyRange;

  function wrap(req) {
    return new Promise(function (resolve, reject) {
      req.onsuccess = function () {
        resolve(req.result);
      };
      req.onerror = function (e) {
        // prevent the transaction from being aborted
        // on a constraint error
        e.preventDefault();
        reject(req.error);
      };
    });
  }

  function IndexedDbStore(storeName, key, indices) {

    var self = this;
    self._ready = false;
    self.storeName = storeName;
    self.indices = indices;
    if (key) {
      self.key = key;
      self.autoIncrement = false;
    } else {
      self.key = "id";
      self.autoIncrement = true;
    }

    self.ready = new Promise(function (resolve, reject) {
      if (!indexedDB) {
        reject('No indexedDB implementation found!');
      }
      var req = indexedDB.open(self.storeName, KEYVALUE_API_VERSION);
      req.onerror = function () {
        reject(req.error);
      };
      req.onsuccess = function () {
        self.db = req.result;
        resolve(self);
      };
      req.onupgradeneeded = function () {
        self.db = req.result;
        var store = self.db.createObjectStore(self.storeName, { keyPath: self.key, autoIncrement: self.autoIncrement });
        // create indices
        for (var i = 0; i < self.indices.length; i++) {
          store.createIndex(self.indices[i], self.indices[i]);
        }
      };
      req.onerror = reject;
    });

    self.ready.then(function() {
      self._ready = true;
    });
  }

  IndexedDbStore.prototype = {

    // Internal function: returns the objectStore with the supplied
    // transaction mode. Defaults to readonly transaction.
    _getTransactionAndStore: function(mode) {
      var self = this;
      mode = typeof mode !== 'undefined' ? mode : 'readonly';
      var tx = self.db.transaction(self.storeName, mode);
      var store = tx.objectStore(self.storeName);
      return {'transaction': tx, 'store': store};
    },

    // Internal function to defer the execution of a supplied function
    // until the database is ready.
    _awaitReady: function(fn, args) {
      var self = this;
      if (self._ready) {
        return fn.apply(self, args);
      } else {
        return self.ready.then(function() {
          return fn.apply(self, args);
        });
      }
    },

    /**
    * Save an object into the database
    * @param {object}   object
    * @return {promise} Promise for the id/key to which
    * it was saved
    */
    insert: function (object) {
      var self = this;
      return self._awaitReady(self._insert, arguments);
    },
    _insert: function (object) {
      var self = this;
      var db = self._getTransactionAndStore('readwrite');
      var promise = wrap(db.store.add(object));
      promise.abort = function(){
        db.transaction.abort();
      };
      return promise;
    },

    /**
     * Update or insert an Object at the given id/key.
     * @param {number}               id
     * @param {string|number|object} object
     * @return {promise}             Promise for the id/key of
     *                               the created object
     */
    set: function (object) {
      var self = this;
      return self._awaitReady(self._set, arguments);
    },
    _set: function (object) {
      var self = this;
      var db = self._getTransactionAndStore('readwrite');
      var promise = wrap(db.store.put(object));
      promise.abort = function(){
        db.transaction.abort();
      };
      return promise;
    },

    /**
    * Update or insert multiple objects into the database
    * @param {objects}  objects
    * @return {promise}
    */
    setMany: function (objects) {
      var self = this;
      return self._awaitReady(self._setMany, arguments);
    },
    _setMany: function (objects) {
      var self = this;
      var db = self._getTransactionAndStore('readwrite');
      var promises = [];
      for (var i = 0; i < objects.length; i++) {
        promises.push(db.store.put(objects[i]));
      }
      var promise = Promise.all(promises);
      promise.abort = function(){
        db.transaction.abort();
      };
      return promise;
    },

    /**
     * Get the object saved at a given id/key.
     * @param  {number|string} key
     * @return {promise}       Promise for the object
     */
    get: function (key) {
      var self = this;
      return self._awaitReady(self._get, arguments);
    },
    _get: function (key) {
      var self = this;
      var db = self._getTransactionAndStore();
      var promise = wrap(db.store.get(key));
      promise.abort = function(){
        db.transaction.abort();
      };
      return promise;
    },

    /**
     * Removes the the entry with the supplied id/key from the database.
     * @param  {number|string} key
     * @return {promise}       Promise for undefined
     */
    remove: function (key) {
      var self = this;
      return self._awaitReady(self._remove, arguments);
    },
    _remove: function (key) {
      var self = this;
      var db = self._getTransactionAndStore('readwrite');
      var promise = wrap(db.store.delete(key));
      promise.abort = function(){
        db.transaction.abort();
      };
      return promise;
    },

    /**
     * Returns multiple database entries.
     * @param  {options}
     *   {any}     start      The first id of the results.
     *   {any}     end        The last id of the results.
     *   {number}  count      The number of results.
     *   {number}  offset     The offset of the first result.
     *   {string}  orderby    The key by which the results will be ordered.
     *   {boolean} reverse    Reverse the order of the results.
     *   use [start] with ([end] or/and [count])
     *   use [offset] with ([end] or/and [count])
     *   using [end] together with [count] the results stop at whatever comes first.
     * @return {promise}      Promise for the objects
     */
    getMany: function(options) {
      var self = this;
      return self._awaitReady(self._getMany, arguments);
    },
    _getMany: function(options) {
      options = options || {};
      var self = this;
      var db = self._getTransactionAndStore();
      var counter = 0;
      var start = options.start;
      var end = options.end;
      var count = options.count || undefined;
      var offset = options.offset || 0;
      var advance = offset === 0 ? false : true;
      var direction = options.reverse ? 'prev' : 'next';
      var orderby = options.orderby;

      // set bound based on options
      var bound;
      if (start && end) {
        bound = IDBKeyRange.bound(start,end);
      } else if (start) {
        bound = IDBKeyRange.lowerBound(start);
      } else if (end) {
        bound = IDBKeyRange.upperBound(end);
      } else {
        bound = null;
      }
      var allItems = [];
      var promise = new Promise(function(resolve,reject){
        var cursorRequest;
        if (!orderby || orderby === self.key) {
          cursorRequest = db.store.openCursor(bound, direction);
        } else {
          var index = db.store.index(orderby);
          cursorRequest = index.openCursor(bound, direction);
        }
        cursorRequest.onsuccess = function(e){
          var cursor = e.target.result;
          // if we reached the end of the items or as many items as
          // requested with the counter, resolve with the result array.
          if (!cursor || (counter !== undefined && counter >= count)) {
            resolve(allItems);
          } else {
            // if we no offset is specified or we skipped ahead
            // already, add the item to the results.
            // else advance the cursor by the offset.
            if (!advance) {
              allItems.push(cursor.value);
              counter++;
              cursor.continue();
            } else {
              advance = false;
              cursor.advance(offset);
            }
          }
        };
      });
      promise.abort = function(){
        db.transaction.abort();
      };
      return promise;
    },

    /**
     * Returns the number of database entries.
     * @return {promise} Promise for the size.
     */
    size: function() {
      var self = this;
      return self._awaitReady(self._size);
    },
    _size: function() {
      var self = this;
      var db = self._getTransactionAndStore();
      var promise = wrap(db.store.count());
      promise.abort = function(){
        db.transaction.abort();
      };
      return promise;
    },

    /**
     * Deletes all database entries.
     * @return {promise} Promise for undefined.
     */
    clear: function () {
      var self = this;
      return self._awaitReady(self._clear);
    },
    _clear: function() {
      var self = this;
      var db = self._getTransactionAndStore('readwrite');
      var promise = wrap(db.store.clear());
      promise.abort = function(){
        db.transaction.abort();
      };
      return promise;
    }
  };

  window.IndexedDbStore = IndexedDbStore;

})();
;
/* global IndexedDbStore */

(function () {

  var BrickStorageIndexeddbElementPrototype = Object.create(HTMLElement.prototype);

  BrickStorageIndexeddbElementPrototype.attachedCallback = function () {
    this.name = this.getAttribute('name') || 'storage';
    this.keyname = this.getAttribute('keyname') || null;
    this.indexnames = this.getAttribute('indexname') ? this.getAttribute('indexname').split(" ") : [];
    this.storage = new IndexedDbStore(this.name, this.keyname, this.indexnames);
  };

  BrickStorageIndexeddbElementPrototype.insert = function (object) {
    return this.storage.insert(object);
  };
  BrickStorageIndexeddbElementPrototype.set = function (object) {
    return this.storage.set(object);
  };
  BrickStorageIndexeddbElementPrototype.setMany = function (objects) {
    return this.storage.setMany(objects);
  };
  BrickStorageIndexeddbElementPrototype.get = function (key) {
    return this.storage.get(key);
  };
  BrickStorageIndexeddbElementPrototype.remove = function (key) {
    return this.storage.remove(key);
  };
  BrickStorageIndexeddbElementPrototype.getMany = function (options) {
    return this.storage.getMany(options);
  };
  BrickStorageIndexeddbElementPrototype.size = function () {
    return this.storage.size();
  };
  BrickStorageIndexeddbElementPrototype.clear = function () {
    return this.storage.clear();
  };

  // Register the element
  window.BrickStorageIndexeddbElement = document.registerElement('brick-storage-indexeddb', {
    prototype: BrickStorageIndexeddbElementPrototype
  });

})();
;
(function () {

  function _onTapbarTabClick(tabEl) {
    if (tabEl.parentNode.nodeName.toLowerCase() === 'brick-tabbar') {
      var targetEvent = tabEl.targetEvent;
      var target = tabEl.targetElement;
      if (target) {
        target.dispatchEvent(new CustomEvent(targetEvent, {'bubbles': true}));
      }
    }
  }

  var BrickTabbarTabElementPrototype = Object.create(HTMLElement.prototype);

  BrickTabbarTabElementPrototype.attachedCallback = function() {
    this.addEventListener('click', function(e) {
      var tabEl = e.currentTarget;
      _onTapbarTabClick(tabEl);
    });
    this.addEventListener('select', function(e) {
      var tabEl = e.currentTarget;
      _onTapbarTabClick(tabEl);
    });
  };

  BrickTabbarTabElementPrototype.select = function() {
    this.dispatchEvent(new CustomEvent('select', {
      'bubbles': true
    }));
  };

  Object.defineProperties(BrickTabbarTabElementPrototype, {
    'target': {
      get: function() {
        return this.getAttribute('target');
      },
      set: function(newVal) {
        this.setAttribute('target', newVal);
      }
    },
    'targetEvent': {
      get: function() {
        if (this.hasAttribute('target-event')) {
          return this.getAttribute('target-event');
        } else if (this.parentNode.nodeName.toLowerCase() === 'brick-tabbar') {
          return this.parentNode.targetEvent;
        } else {
          throw 'tabbar-tab is missing event to fire';
        }
      },
      set: function(newVal) {
        this.setAttribute('target-event', newVal);
      }
    },
    'targetElement': {
      get: function() {
        if (this.overrideElement) {
          return this.overrideElement;
        } else {
          return document.getElementById(this.target);
        }
      },
      set: function(newVal) {
        this.overrideElement = newVal;
        this.removeAttribute('target');
      }
    }
  });

  if (!window.BrickTabbarTabElement) {
    window.BrickTabbarTabElement = document.registerElement('brick-tabbar-tab', {
      prototype: BrickTabbarTabElementPrototype
    });
  }

})();
;
/* global Platform */

(function () {

  var currentScript = document._currentScript || document.currentScript;

  function delegate(selector, handler) {
    return function(e) {
      var target = e.target;
      var delegateEl = e.currentTarget;
      var matches = delegateEl.querySelectorAll(selector);
      for (var el = target; el.parentNode && el !== delegateEl; el = el.parentNode) {
        for (var i = 0; i < matches.length; i++) {
          if (matches[i] === el) {
            handler.call(el, e);
            return;
          }
        }
      }
    };
  }

  function _selectTab(tabEl) {
    var tabbar = tabEl.parentNode;
    var activeTab = tabbar.querySelectorAll('brick-tabbar-tab[selected]');
    for (var i = 0; i < activeTab.length; i++) {
      activeTab[i].removeAttribute('selected');
    }
    tabEl.setAttribute('selected', true);

    // move the indicator
    var index = tabbar.tabs.indexOf(tabEl);
    var indicator = tabbar.selectedIndicator;

    if (tabbar.hasAttribute('vertical')) {
      tabbar.selectedIndicator.style.height = 100 / tabbar.tabs.length + '%';
      indicator.style.webkitTransform = 'translateY(' + 100 * index + '%)';
      indicator.style.transform = 'translateY(' + 100 * index + '%)';
    } else {
      tabbar.selectedIndicator.style.width = 100 / tabbar.tabs.length + '%';
      indicator.style.webkitTransform = 'translateX(' + 100 * index + '%)';
      indicator.style.transform = 'translateX(' + 100 * index + '%)';
    }
  }

  var BrickTabbarElementPrototype = Object.create(HTMLElement.prototype);

  BrickTabbarElementPrototype.attachedCallback = function() {

    var importDoc = currentScript.ownerDocument;
    var template = importDoc.querySelector('#brick-tabbar-template');

    // fix styling for polyfill
    if (Platform.ShadowCSS) {
      var styles = template.content.querySelectorAll('style');
      for (var i = 0; i < styles.length; i++) {
        var style = styles[i];
        var cssText = Platform.ShadowCSS.shimStyle(style, 'brick-tabbar');
        Platform.ShadowCSS.addCssToDocument(cssText);
        style.remove();
      }
    }

    // create shadowRoot and append template to it.
    var shadowRoot = this.createShadowRoot();
    shadowRoot.appendChild(template.content.cloneNode(true));

    // listen to click and select events
    this.selectedIndicator = shadowRoot.querySelector('.selected-indicator');
    this.selectHandler = delegate('brick-tabbar-tab', function(){
      _selectTab(this);
    });
    this.addEventListener('click', this.selectHandler);
    this.addEventListener('select', this.selectHandler);

    // initially set the selected tab,
    // if none has the attribute [selected]
    // then select the first one
    var tabEl = this.selectedTab;
    if (tabEl) {
      _selectTab(tabEl);
    } else {
      var firstTab = this.querySelector('brick-tabbar-tab');
      if (firstTab) {
        firstTab.dispatchEvent(new CustomEvent('select', {
          'bubbles': true
        }));
      }
    }

    // check for new tabs being added and call selectTab() again,
    // to correct the size of the indicator
    var observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        var tabbar = mutation.target;
        if (mutation.type === "childList") {
          _selectTab(tabbar.selectedTab);
        }
      });
    });
    observer.observe(this, { childList: true });
  };

  BrickTabbarElementPrototype.detachedCallback = function() {
    this.removeEventListener('click', this.selectHandler);
    this.removeEventListener('select', this.selectHandler);
  };

  Object.defineProperties(BrickTabbarElementPrototype, {
    'targetEvent': {
      get: function() {
        return this.getAttribute('target-event') || 'reveal';
      },
      set: function(newVal) {
        this.setAttribute('target-event', newVal);
      }
    },
    'tabs': {
      get: function() {
        var tabList = this.querySelectorAll('brick-tabbar-tab');
        return Array.prototype.slice.call(tabList);
      }
    },
    'selectedTab': {
      get: function() {
        return this.querySelector('brick-tabbar-tab[selected]');
      }
    }
  });

  if (!window.BrickTabbarElement) {
    window.BrickTabbarElement = document.registerElement('brick-tabbar', {
      prototype: BrickTabbarElementPrototype
    });
  }

})();
;
(function () {

  var BrickActionElementPrototype = Object.create(HTMLElement.prototype);

  function cleanupHandler(el) {
    var pair = el._ns.listener;
    if (pair && pair[0]) {
      pair[0].removeEventListener(pair[1], pair[2]);
    }
  }

  function makeHandler(method, target) {
    return function(e) {
      var data = e.detail;
      if (method in target && typeof target[method] === 'function') {
        target[method](data);
      }
    };
  }

  function setupHandler(el) {
    var source = el.getAttribute('source');
    var trigger = el.getAttribute('trigger') || 'click';
    var action = el.getAttribute('action');
    var target = el.getAttribute('target');
    var sourceEl;
    if (!action || !target) {
      return;
    }
    var targetEl = document.getElementById(target);
    if (!targetEl) {
      return;
    }
    if (source) {
      sourceEl = document.getElementById(source);
    }
    if (!sourceEl) {
      sourceEl = el;
    }
    var listener = makeHandler(action, targetEl);
    el._ns.listener = [sourceEl, trigger, listener];
    sourceEl.addEventListener(trigger, listener);
  }

  BrickActionElementPrototype.createdCallback = function () {
    this._ns = {};
  };

  BrickActionElementPrototype.attachedCallback = function () {
    setupHandler(this);
  };

  BrickActionElementPrototype.detachedCallback = function () {
    cleanupHandler(this);

  };

  BrickActionElementPrototype.attributeChangedCallback = function () {
    cleanupHandler(this);
    setupHandler(this);
  };

  if (!window.BrickActionElement) {
    window.BrickActionElement = document.registerElement('brick-action', {
      prototype: BrickActionElementPrototype
    });
  }

})();
;
/* global Platform */

(function () {

  var currentScript = document._currentScript || document.currentScript;

  function shimShadowStyles(styles, tag) {
    if (!Platform.ShadowCSS) {
      return;
    }
    for (var i = 0; i < styles.length; i++) {
      var style = styles[i];
      var cssText = Platform.ShadowCSS.shimStyle(style, tag);
      Platform.ShadowCSS.addCssToDocument(cssText);
      style.remove();
    }
  }

  var BrickButtonElementPrototype = Object.create(window.BrickActionElement.prototype);

  // Lifecycle methods

  BrickButtonElementPrototype.createdCallback = function () {

    window.BrickActionElement.prototype.createdCallback.call(this);

    // import template
    var importDoc = currentScript.ownerDocument;
    var templateContent = importDoc.querySelector('#brick-button-template').content;

    // fix styling for polyfill
    shimShadowStyles(templateContent.querySelectorAll('style'),'brick-button');

    // create shadowRoot and append template
    var shadowRoot = this.createShadowRoot();
    shadowRoot.appendChild(templateContent.cloneNode(true));

    this.setAttribute('role', 'button');

  };

  // Register the element

  window.BrickButtonElement = document.registerElement('brick-button', {
    prototype: BrickButtonElementPrototype
  });

})();
