<html><head>
<title>curl_easy_setopt man page</title>
<meta name="generator" content="roffit 0.5">
<STYLE type="text/css">
P.level0 {
 padding-left: 2em;
}

P.level1 {
 padding-left: 4em;
}

P.level2 {
 padding-left: 6em;
}

span.emphasis {
 font-style: italic;
}

span.bold {
 font-weight: bold;
}

span.manpage {
 font-weight: bold;
}

h2.nroffsh {
 background-color: #e0e0e0;
}

span.nroffip {
 font-weight: bold;
 font-size: 120%;
 font-family: monospace;
}

p.roffit {
 text-align: center;
 font-size: 80%;
}
</STYLE>
</head><body>

<p class="level0"><a name="NAME"></a><h2 class="nroffsh">NAME</h2>
<p class="level0">curl_easy_setopt - set options for a curl easy handle <a name="SYNOPSIS"></a><h2 class="nroffsh">SYNOPSIS</h2>
<p class="level0">#include &lt;curl/curl.h&gt; 
<p class="level0">CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter); <a name="DESCRIPTION"></a><h2 class="nroffsh">DESCRIPTION</h2>
<p class="level0">curl_easy_setopt() is used to tell libcurl how to behave. By using the appropriate options to <span Class="emphasis">curl_easy_setopt</span>, you can change libcurl's behavior.  All options are set with the <span Class="emphasis">option</span> followed by a <span Class="emphasis">parameter</span>. That parameter can be a long, a function pointer or an object pointer, all depending on what the specific option expects. Read this manual carefully as bad input values may cause libcurl to behave badly!  You can only set one option in each function call. A typical application uses many curl_easy_setopt() calls in the setup phase. 
<p class="level0">Options set with this function call are valid for all forthcoming transfers performed using this <span Class="emphasis">handle</span>.  The options are not in any way reset between transfers, so if you want subsequent transfers with different options, you must change them between the transfers. 
<p class="level0"><span Class="bold">NOTE:</span> strings passed to libcurl as 'char *' arguments, will not be copied by the library. Instead you should keep them available until libcurl no longer needs them. Failing to do so will cause very odd behavior or even crashes. libcurl will need them until you call <a class="emphasis" href="./curl_easy_cleanup.html">curl_easy_cleanup(3)</a> or you set the same option again to use a different pointer. 
<p class="level0">The <span Class="emphasis">handle</span> is the return code from a <a class="emphasis" href="./curl_easy_init.html">curl_easy_init(3)</a> or <a class="emphasis" href="./curl_easy_duphandle.html">curl_easy_duphandle(3)</a> call. <a name="BEHAVIOR"></a><h2 class="nroffsh">BEHAVIOR OPTIONS</h2>
<p class="level0">
<p class="level0"><a name="CURLOPTVERBOSE"></a><span class="nroffip">CURLOPT_VERBOSE</span> 
<p class="level1">Set the parameter to non-zero to get the library to display a lot of verbose information about its operations. Very useful for libcurl and/or protocol debugging and understanding. The verbose information will be sent to stderr, or the stream set with <a class="emphasis" href="#CURLOPTSTDERR">CURLOPT_STDERR</a>. 
<p class="level1">You hardly ever want this set in production use, you will almost always want this when you debug/report problems. Another neat option for debugging is the <a class="emphasis" href="#CURLOPTDEBUGFUNCTION">CURLOPT_DEBUGFUNCTION</a>. 
<p class="level0"><a name="CURLOPTHEADER"></a><span class="nroffip">CURLOPT_HEADER</span> 
<p class="level1">A non-zero parameter tells the library to include the header in the body output. This is only relevant for protocols that actually have headers preceding the data (like HTTP). 
<p class="level0"><a name="CURLOPTNOPROGRESS"></a><span class="nroffip">CURLOPT_NOPROGRESS</span> 
<p class="level1">A non-zero parameter tells the library to shut off the built-in progress meter completely. 
<p class="level1"><span Class="bold">NOTE:</span> future versions of libcurl is likely to not have any built-in progress meter at all. 
<p class="level0"><a name="CURLOPTNOSIGNAL"></a><span class="nroffip">CURLOPT_NOSIGNAL</span> 
<p class="level1">Pass a long. If it is non-zero, libcurl will not use any functions that install signal handlers or any functions that cause signals to be sent to the process. This option is mainly here to allow multi-threaded unix applications to still set/use all timeout options etc, without risking getting signals. (Added in 7.10) 
<p class="level1">Consider building libcurl with ares support to enable asynchronous DNS lookups. It enables nice timeouts for name resolves without signals. <a name="CALLBACK"></a><h2 class="nroffsh">CALLBACK OPTIONS</h2>
<p class="level0">
<p class="level0"><a name="CURLOPTWRITEFUNCTION"></a><span class="nroffip">CURLOPT_WRITEFUNCTION</span> 
<p class="level1">Function pointer that should match the following prototype: <span class="bold">size_t function( void *ptr, size_t size, size_t nmemb, void *stream);</span> This function gets called by libcurl as soon as there is data reveiced that needs to be saved. The size of the data pointed to by <span Class="emphasis">ptr</span> is <span Class="emphasis">size</span> multiplied with <span Class="emphasis">nmemb</span>, it will not be zero terminated. Return the number of bytes actually taken care of. If that amount differs from the amount passed to your function, it'll signal an error to the library and it will abort the transfer and return <span Class="emphasis">CURLE_WRITE_ERROR</span>. 
<p class="level1">Set the <span Class="emphasis">stream</span> argument with the <a class="emphasis" href="#CURLOPTWRITEDATA">CURLOPT_WRITEDATA</a> option. 
<p class="level1"><span Class="bold">NOTE:</span> you will be passed as much data as possible in all invokes, but you cannot possibly make any assumptions. It may be one byte, it may be thousands. The maximum amount of data that can be passed to the write callback is defined in the curl.h header file: CURL_MAX_WRITE_SIZE. 
<p class="level0"><a name="CURLOPTWRITEDATA"></a><span class="nroffip">CURLOPT_WRITEDATA</span> 
<p class="level1">Data pointer to pass to the file write function. Note that if you specify the <a class="emphasis" href="#CURLOPTWRITEFUNCTION">CURLOPT_WRITEFUNCTION</a>, this is the pointer you'll get as input. If you don't use a callback, you must pass a 'FILE *' as libcurl will pass this to fwrite() when writing data. 
<p class="level1"><span Class="bold">NOTE:</span> If you're using libcurl as a win32 DLL, you MUST use the <a class="emphasis" href="#CURLOPTWRITEFUNCTION">CURLOPT_WRITEFUNCTION</a> if you set this option or you will experience crashes. 
<p class="level1">This option is also known with the older name <span Class="emphasis">CURLOPT_FILE</span>, the name <a class="emphasis" href="#CURLOPTWRITEDATA">CURLOPT_WRITEDATA</a> was introduced in 7.9.7. 
<p class="level0"><a name="CURLOPTREADFUNCTION"></a><span class="nroffip">CURLOPT_READFUNCTION</span> 
<p class="level1">Function pointer that should match the following prototype: <span class="bold">size_t function( void *ptr, size_t size, size_t nmemb, void *stream);</span> This function gets called by libcurl as soon as it needs to read data in order to send it to the peer. The data area pointed at by the pointer <span Class="emphasis">ptr</span> may be filled with at most <span Class="emphasis">size</span> multiplied with <span Class="emphasis">nmemb</span> number of bytes. Your function must return the actual number of bytes that you stored in that memory area. Returning 0 will signal end-of-file to the library and cause it to stop the current transfer. 
<p class="level0"><a name="CURLOPTREADDATA"></a><span class="nroffip">CURLOPT_READDATA</span> 
<p class="level1">Data pointer to pass to the file read function. Note that if you specify the <a class="emphasis" href="#CURLOPTREADFUNCTION">CURLOPT_READFUNCTION</a>, this is the pointer you'll get as input. If you don't specify a read callback, this must be a valid FILE *. 
<p class="level1"><span Class="bold">NOTE:</span> If you're using libcurl as a win32 DLL, you MUST use a <a class="emphasis" href="#CURLOPTREADFUNCTION">CURLOPT_READFUNCTION</a> if you set this option. 
<p class="level1">This option is also known with the older name <span Class="emphasis">CURLOPT_INFILE</span>, the name <a class="emphasis" href="#CURLOPTREADDATA">CURLOPT_READDATA</a> was introduced in 7.9.7. 
<p class="level0"><a name="CURLOPTPROGRESSFUNCTION"></a><span class="nroffip">CURLOPT_PROGRESSFUNCTION</span> 
<p class="level1">Function pointer that should match the <span Class="emphasis">curl_progress_callback</span> prototype found in <span Class="emphasis">&lt;curl/curl.h&gt;</span>. This function gets called by libcurl instead of its internal equivalent with a frequent interval during data transfer. Unknown/unused argument values will be set to zero (like if you only download data, the upload size will remain 0). Returning a non-zero value from this callback will cause libcurl to abort the transfer and return <span Class="emphasis">CURLE_ABORTED_BY_CALLBACK</span>. 
<p class="level1">Also note that <a class="emphasis" href="#CURLOPTNOPROGRESS">CURLOPT_NOPROGRESS</a> must be set to FALSE to make this function actually get called. 
<p class="level0"><a name="CURLOPTPROGRESSDATA"></a><span class="nroffip">CURLOPT_PROGRESSDATA</span> 
<p class="level1">Pass a pointer that will be untouched by libcurl and passed as the first argument in the progress callback set with <a class="emphasis" href="#CURLOPTPROGRESSFUNCTION">CURLOPT_PROGRESSFUNCTION</a>. 
<p class="level0"><a name="CURLOPTHEADERFUNCTION"></a><span class="nroffip">CURLOPT_HEADERFUNCTION</span> 
<p class="level1">Function pointer that should match the following prototype: <span class="emphasis">size_t function( void *ptr, size_t size, size_t nmemb, void *stream);</span>. This function gets called by libcurl as soon as there is received header data that needs to be written down. The headers are guaranteed to be written one-by-one and only complete lines are written. Parsing headers should be easy enough using this. The size of the data pointed to by <span Class="emphasis">ptr</span> is <span Class="emphasis">size</span> multiplied with <span Class="emphasis">nmemb</span>.  The pointer named <span Class="emphasis">stream</span> will be the one you passed to libcurl with the <a class="emphasis" href="#CURLOPTWRITEHEADER">CURLOPT_WRITEHEADER</a> option.  Return the number of bytes actually written or return -1 to signal error to the library (it will cause it to abort the transfer with a <span Class="emphasis">CURLE_WRITE_ERROR</span> return code). 
<p class="level0"><a name="CURLOPTWRITEHEADER"></a><span class="nroffip">CURLOPT_WRITEHEADER</span> 
<p class="level1">Pass a pointer to be used to write the header part of the received data to. If you don't use your own callback to take care of the writing, this must be a valid FILE *. See also the <a class="emphasis" href="#CURLOPTHEADERFUNCTION">CURLOPT_HEADERFUNCTION</a> option above on how to set a custom get-all-headers callback. 
<p class="level0"><a name="CURLOPTDEBUGFUNCTION"></a><span class="nroffip">CURLOPT_DEBUGFUNCTION</span> 
<p class="level1">Function pointer that should match the following prototype: <span class="emphasis">int curl_debug_callback (CURL *, curl_infotype, char *, size_t, void *);</span> <a class="emphasis" href="#CURLOPTDEBUGFUNCTION">CURLOPT_DEBUGFUNCTION</a> replaces the standard debug function used when <a class="emphasis" href="#CURLOPTVERBOSE">CURLOPT_VERBOSE </a> is in effect. This callback receives debug information, as specified with the <span Class="bold">curl_infotype</span> argument. This funtion must return 0.  The data pointed to by the char * passed to this function WILL NOT be zero terminated, but will be exactly of the size as told by the size_t argument. 
<p class="level1">Available curl_infotype values: 
<p class="level2">
<p class="level1"><a name="CURLINFOTEXT"></a><span class="nroffip">CURLINFO_TEXT</span> 
<p class="level2">The data is informational text. 
<p class="level1"><a name="CURLINFOHEADERIN"></a><span class="nroffip">CURLINFO_HEADER_IN</span> 
<p class="level2">The data is header (or header-like) data received from the peer. 
<p class="level1"><a name="CURLINFOHEADEROUT"></a><span class="nroffip">CURLINFO_HEADER_OUT</span> 
<p class="level2">The data is header (or header-like) data sent to the peer. 
<p class="level1"><a name="CURLINFODATAIN"></a><span class="nroffip">CURLINFO_DATA_IN</span> 
<p class="level2">The data is protocol data received from the peer. 
<p class="level1"><a name="CURLINFODATAOUT"></a><span class="nroffip">CURLINFO_DATA_OUT</span> 
<p class="level2">The data is protocol data sent to the peer. 
<p class="level1">
<p class="level0"><a name="CURLOPTDEBUGDATA"></a><span class="nroffip">CURLOPT_DEBUGDATA</span> 
<p class="level1">Pass a pointer to whatever you want passed in to your <a class="emphasis" href="#CURLOPTDEBUGFUNCTION">CURLOPT_DEBUGFUNCTION</a> in the last void * argument. This pointer is not used by libcurl, it is only passed to the callback. 
<p class="level0"><a name="CURLOPTSSLCTXFUNCTION"></a><span class="nroffip">CURLOPT_SSL_CTX_FUNCTION</span> 
<p class="level1">Function pointer that should match the following prototype: <span class="bold">CURLcode sslctxfun(CURL *curl, void *sslctx, void *parm);</span> This function gets called by libcurl just before the initialization of an SSL connection after having processed all other SSL related options to give a last chance to an application to modify the behaviour of openssl's ssl initilaization. The <span Class="emphasis">sslctx</span> parameter is actually a pointer to an openssl <span Class="emphasis">SSL_CTX</span>. If an error is returned no attempt to establish a connection is made and the perform operation will return the error code from this callback function.  Set the <span Class="emphasis">parm</span> argument with the <a class="emphasis" href="#CURLOPTSSLCTXDATA">CURLOPT_SSL_CTX_DATA</a> option. This option was introduced in 7.11.0. 
<p class="level1"><span Class="bold">NOTE:</span> To use this properly, a non-trivial amount of knowledge of the openssl libraries is necessary. Using this function allows for example to use openssl callbacks to add additional validation code for certificates, and even to change the actual URI of an HTTPS request (example used in the lib509 test case).  See also the example section for a replacement of the key, certificate and trust file settings. 
<p class="level0"><a name="CURLOPTSSLCTXDATA"></a><span class="nroffip">CURLOPT_SSL_CTX_DATA</span> 
<p class="level1">Data pointer to pass to the ssl context callback set by the option <a class="emphasis" href="#CURLOPTSSLCTXFUNCTION">CURLOPT_SSL_CTX_FUNCTION</a>, this is the pointer you'll get as third parameter, otherwise <span Class="bold">NULL</span>. (Added in 7.11.0) <a name="ERROR"></a><h2 class="nroffsh">ERROR OPTIONS</h2>
<p class="level0">
<p class="level0"><a name="CURLOPTERRORBUFFER"></a><span class="nroffip">CURLOPT_ERRORBUFFER</span> 
<p class="level1">Pass a char * to a buffer that the libcurl may store human readable error messages in. This may be more helpful than just the return code from the library. The buffer must be at least CURL_ERROR_SIZE big. 
<p class="level1">Use <a class="emphasis" href="#CURLOPTVERBOSE">CURLOPT_VERBOSE</a> and <a class="emphasis" href="#CURLOPTDEBUGFUNCTION">CURLOPT_DEBUGFUNCTION</a> to better debug/trace why errors happen. 
<p class="level1"><span Class="bold">Note:</span> if the library does not return an error, the buffer may not have been touched. Do not rely on the contents in those cases. 
<p class="level0"><a name="CURLOPTSTDERR"></a><span class="nroffip">CURLOPT_STDERR</span> 
<p class="level1">Pass a FILE * as parameter. Tell libcurl to use this stream instead of stderr when showing the progress meter and displaying <a class="emphasis" href="#CURLOPTVERBOSE">CURLOPT_VERBOSE</a> data. 
<p class="level0"><a name="CURLOPTFAILONERROR"></a><span class="nroffip">CURLOPT_FAILONERROR</span> 
<p class="level1">A non-zero parameter tells the library to fail silently if the HTTP code returned is equal to or larger than 300. The default action would be to return the page normally, ignoring that code. <a name="NETWORK"></a><h2 class="nroffsh">NETWORK OPTIONS</h2>
<p class="level0">
<p class="level0"><a name="CURLOPTURL"></a><span class="nroffip">CURLOPT_URL</span> 
<p class="level1">The actual URL to deal with. The parameter should be a char * to a zero terminated string. The string must remain present until curl no longer needs it, as it doesn't copy the string. 
<p class="level1">If the given URL lacks the protocol part ("http://" or "ftp://" etc), it will attempt to guess which protocol to use based on the given host name. If the given protocol of the set URL is not supported, libcurl will return on error (<span Class="emphasis">CURLE_UNSUPPORTED_PROTOCOL</span>) when you call <a class="emphasis" href="./curl_easy_perform.html">curl_easy_perform(3)</a> or <a class="emphasis" href="./curl_multi_perform.html">curl_multi_perform(3)</a>. Use <a class="emphasis" href="./curl_version_info.html">curl_version_info(3)</a> for detailed info on which protocols that are supported. 
<p class="level1"><span Class="bold">NOTE:</span> <a class="emphasis" href="#CURLOPTURL">CURLOPT_URL</a> is the only option that must be set before <a class="emphasis" href="./curl_easy_perform.html">curl_easy_perform(3)</a> is called. 
<p class="level0"><a name="CURLOPTPROXY"></a><span class="nroffip">CURLOPT_PROXY</span> 
<p class="level1">Set HTTP proxy to use. The parameter should be a char * to a zero terminated string holding the host name or dotted IP address. To specify port number in this string, append :[port] to the end of the host name. The proxy string may be prefixed with [protocol]:// since any such prefix will be ignored. The proxy's port number may optionally be specified with the separate option <a class="emphasis" href="#CURLOPTPROXYPORT">CURLOPT_PROXYPORT</a>. 
<p class="level1"><span Class="bold">NOTE:</span> when you tell the library to use a HTTP proxy, libcurl will transparently convert operations to HTTP even if you specify a FTP URL etc. This may have an impact on what other features of the library you can use, such as <a class="emphasis" href="#CURLOPTQUOTE">CURLOPT_QUOTE</a> and similar FTP specifics that don't work unless you tunnel through the HTTP proxy. Such tunneling is activated with <a class="emphasis" href="#CURLOPTHTTPPROXYTUNNEL">CURLOPT_HTTPPROXYTUNNEL</a>. 
<p class="level1"><span Class="bold">NOTE2:</span> libcurl respects the environment variables <span Class="bold">http_proxy</span>, <span Class="bold">ftp_proxy</span>, <span Class="bold">all_proxy</span> etc, if any of those is set. 
<p class="level0"><a name="CURLOPTPROXYPORT"></a><span class="nroffip">CURLOPT_PROXYPORT</span> 
<p class="level1">Pass a long with this option to set the proxy port to connect to unless it is specified in the proxy string <a class="emphasis" href="#CURLOPTPROXY">CURLOPT_PROXY</a>. 
<p class="level0"><a name="CURLOPTPROXYTYPE"></a><span class="nroffip">CURLOPT_PROXYTYPE</span> 
<p class="level1">Pass a long with this option to set type of the proxy. Available options for this are <span Class="emphasis">CURLPROXY_HTTP</span> and <span Class="emphasis">CURLPROXY_SOCKS5</span>, with the HTTP one being default. (Added in 7.10) 
<p class="level0"><a name="CURLOPTHTTPPROXYTUNNEL"></a><span class="nroffip">CURLOPT_HTTPPROXYTUNNEL</span> 
<p class="level1">Set the parameter to non-zero to get the library to tunnel all operations through a given HTTP proxy. Note that there is a big difference between using a proxy and to tunnel through it. If you don't know what this means, you probably don't want this tunneling option. 
<p class="level0"><a name="CURLOPTINTERFACE"></a><span class="nroffip">CURLOPT_INTERFACE</span> 
<p class="level1">Pass a char * as parameter. This set the interface name to use as outgoing network interface. The name can be an interface name, an IP address or a host name. 
<p class="level0"><a name="CURLOPTDNSCACHETIMEOUT"></a><span class="nroffip">CURLOPT_DNS_CACHE_TIMEOUT</span> 
<p class="level1">Pass a long, this sets the timeout in seconds. Name resolves will be kept in memory for this number of seconds. Set to zero (0) to completely disable caching, or set to -1 to make the cached entries remain forever. By default, libcurl caches this info for 60 seconds. 
<p class="level0"><a name="CURLOPTDNSUSEGLOBALCACHE"></a><span class="nroffip">CURLOPT_DNS_USE_GLOBAL_CACHE</span> 
<p class="level1">Pass a long. If the value is non-zero, it tells curl to use a global DNS cache that will survive between easy handle creations and deletions. This is not thread-safe and this will use a global varible. 
<p class="level1"><span Class="bold">WARNING:</span> this option is considered obsolete. Stop using it. Switch over to using the share interface instead! See <a class="emphasis" href="#CURLOPTSHARE">CURLOPT_SHARE</a> and <a class="emphasis" href="./curl_share_init.html">curl_share_init(3)</a>. 
<p class="level0"><a name="CURLOPTBUFFERSIZE"></a><span class="nroffip">CURLOPT_BUFFERSIZE</span> 
<p class="level1">Pass a long specifying your prefered size for the receive buffer in libcurl. The main point of this would be that the write callback gets called more often and with smaller chunks. This is just treated as a request, not an order. You cannot be guaranteed to actually get the given size. (Added in 7.10) 
<p class="level0"><a name="CURLOPTPORT"></a><span class="nroffip">CURLOPT_PORT</span> 
<p class="level1">Pass a long specifying what remote port number to connect to, instead of the one specified in the URL or the default port for the used protocol. <a name="NAMES"></a><h2 class="nroffsh">NAMES and PASSWORDS OPTIONS (Authentication)</h2>
<p class="level0">
<p class="level0"><a name="CURLOPTNETRC"></a><span class="nroffip">CURLOPT_NETRC</span> 
<p class="level1">This parameter controls the preference of libcurl between using user names and passwords from your <span Class="emphasis">~/.netrc</span> file, relative to user names and passwords in the URL supplied with <a class="emphasis" href="#CURLOPTURL">CURLOPT_URL</a>. 
<p class="level1"><span Class="bold">Note:</span> libcurl uses a user name (and supplied or prompted password) supplied with <a class="emphasis" href="#CURLOPTUSERPWD">CURLOPT_USERPWD</a> in preference to any of the options controlled by this parameter. 
<p class="level1">Pass a long, set to one of the values described below. 
<p class="level2">
<p class="level1"><a name="CURLNETRCOPTIONAL"></a><span class="nroffip">CURL_NETRC_OPTIONAL</span> 
<p class="level2">The use of your <span Class="emphasis">~/.netrc</span> file is optional, and information in the URL is to be preferred.  The file will be scanned with the host and user name (to find the password only) or with the host only, to find the first user name and password after that <span Class="emphasis">machine</span>, which ever information is not specified in the URL. 
<p class="level2">Undefined values of the option will have this effect. 
<p class="level1"><a name="CURLNETRCIGNORED"></a><span class="nroffip">CURL_NETRC_IGNORED</span> 
<p class="level2">The library will ignore the file and use only the information in the URL. 
<p class="level2">This is the default. 
<p class="level1"><a name="CURLNETRCREQUIRED"></a><span class="nroffip">CURL_NETRC_REQUIRED</span> 
<p class="level2">This value tells the library that use of the file is required, to ignore the information in the URL, and to search the file with the host only. 
<p class="level1">Only machine name, user name and password are taken into account  (init macros and similar things aren't supported). 
<p class="level1"><span Class="bold">Note:</span> libcurl does not verify that the file has the correct properties set (as the standard Unix ftp client does). It should only be readable by user. 
<p class="level0"><a name="CURLOPTNETRCFILE"></a><span class="nroffip">CURLOPT_NETRC_FILE</span> 
<p class="level1">Pass a char * as parameter, pointing to a zero terminated string containing the full path name to the file you want libcurl to use as .netrc file. If this option is omitted, and <a class="emphasis" href="#CURLOPTNETRC">CURLOPT_NETRC</a> is set, libcurl will attempt to find the a .netrc file in the current user's home directory. (Added in 7.10.9) 
<p class="level0"><a name="CURLOPTUSERPWD"></a><span class="nroffip">CURLOPT_USERPWD</span> 
<p class="level1">Pass a char * as parameter, which should be [user name]:[password] to use for the connection. Use <a class="emphasis" href="#CURLOPTHTTPAUTH">CURLOPT_HTTPAUTH</a> to decide authentication method. 
<p class="level1">When using HTTP and <a class="emphasis" href="#CURLOPTFOLLOWLOCATION">CURLOPT_FOLLOWLOCATION</a>, libcurl might perform several requests to possibly different hosts. libcurl will only send this user and password information to hosts using the initial host name (unless <a class="emphasis" href="#CURLOPTUNRESTRICTEDAUTH">CURLOPT_UNRESTRICTED_AUTH</a> is set), so if libcurl follows locations to other hosts it will not send the user and password to those. This is enforced to prevent accidental information leakage. 
<p class="level0"><a name="CURLOPTPROXYUSERPWD"></a><span class="nroffip">CURLOPT_PROXYUSERPWD</span> 
<p class="level1">Pass a char * as parameter, which should be [user name]:[password] to use for the connection to the HTTP proxy.  Use <a class="emphasis" href="#CURLOPTPROXYAUTH">CURLOPT_PROXYAUTH</a> to decide authentication method. 
<p class="level0"><a name="CURLOPTHTTPAUTH"></a><span class="nroffip">CURLOPT_HTTPAUTH</span> 
<p class="level1">Pass a long as parameter, which is set to a bitmask, to tell libcurl what authentication method(s) you want it to use. The available bits are listed below. If more than one bit is set, libcurl will first query the site to see what authentication methods it supports and then pick the best one you allow it to use. Note that for some methods, this will induce an extra network round-trip. Set the actual name and password with the <a class="emphasis" href="#CURLOPTUSERPWD">CURLOPT_USERPWD</a> option. (Added in 7.10.6) 
<p class="level2">
<p class="level1"><a name="CURLAUTHBASIC"></a><span class="nroffip">CURLAUTH_BASIC</span> 
<p class="level2">HTTP Basic authentication. This is the default choice, and the only method that is in wide-spread use and supported virtually everywhere. This is sending the user name and password over the network in plain text, easily captured by others. 
<p class="level1"><a name="CURLAUTHDIGEST"></a><span class="nroffip">CURLAUTH_DIGEST</span> 
<p class="level2">HTTP Digest authentication.  Digest authentication is defined in RFC2617 and is a more secure way to do authentication over public networks than the regular old-fashioned Basic method. 
<p class="level1"><a name="CURLAUTHGSSNEGOTIATE"></a><span class="nroffip">CURLAUTH_GSSNEGOTIATE</span> 
<p class="level2">HTTP GSS-Negotiate authentication. The GSS-Negotiate (also known as plain "Negotiate") method was designed by Microsoft and is used in their web aplications. It is primarily meant as a support for Kerberos5 authentication but may be also used along with another authentication methods. For more information see IETF draft draft-brezak-spnego-http-04.txt. 
<p class="level2"><span Class="bold">NOTE</span> that you need to build libcurl with a suitable GSS-API library for this to work. 
<p class="level1"><a name="CURLAUTHNTLM"></a><span class="nroffip">CURLAUTH_NTLM</span> 
<p class="level2">HTTP NTLM authentication. A proprietary protocol invented and used by Microsoft. It uses a challenge-response and hash concept similar to Digest, to prevent the password from being evesdropped. 
<p class="level2"><span Class="bold">NOTE</span> that you need to build libcurl with SSL support for this option to work. 
<p class="level1"><a name="CURLAUTHANY"></a><span class="nroffip">CURLAUTH_ANY</span> 
<p class="level2">This is a convenience macro that sets all bits and thus makes libcurl pick any it finds suitable. libcurl will automaticly select the one it finds most secure. 
<p class="level1"><a name="CURLAUTHANYSAFE"></a><span class="nroffip">CURLAUTH_ANYSAFE</span> 
<p class="level2">This is a convenience macro that sets all bits except Basic and thus makes libcurl pick any it finds suitable. libcurl will automaticly select the one it finds most secure. 
<p class="level1">
<p class="level0"><a name="CURLOPTPROXYAUTH"></a><span class="nroffip">CURLOPT_PROXYAUTH</span> 
<p class="level1">Pass a long as parameter, which is set to a bitmask, to tell libcurl what authentication method(s) you want it to use for your proxy authentication.  If more than one bit is set, libcurl will first query the site to see what authentication methods it supports and then pick the best one you allow it to use. Note that for some methods, this will induce an extra network round-trip. Set the actual name and password with the <a class="emphasis" href="#CURLOPTPROXYUSERPWD">CURLOPT_PROXYUSERPWD</a> option. The bitmask can be constructed by or'ing together the bits listed above for the <a class="emphasis" href="#CURLOPTHTTPAUTH">CURLOPT_HTTPAUTH</a> option. As of this writing, only Basic and NTLM work. (Added in 7.10.7) <a name="HTTP"></a><h2 class="nroffsh">HTTP OPTIONS</h2>
<p class="level0">
<p class="level0"><a name="CURLOPTAUTOREFERER"></a><span class="nroffip">CURLOPT_AUTOREFERER</span> 
<p class="level1">Pass a non-zero parameter to enable this. When enabled, libcurl will automaticly set the Referer: field in requests where it follows a Location: redirect. 
<p class="level0"><a name="CURLOPTENCODING"></a><span class="nroffip">CURLOPT_ENCODING</span> 
<p class="level1">Sets the contents of the Accept-Encoding: header sent in an HTTP request, and enables decoding of a response when a Content-Encoding: header is received.  Three encodings are supported: <span Class="emphasis">identity</span>, which does nothing, <span Class="emphasis">deflate</span> which requests the server to compress its response using the zlib algorithm, and <span Class="emphasis">gzip</span> which requests the gzip algorithm.  If a zero-length string is set, then an Accept-Encoding: header containing all supported encodings is sent. 
<p class="level1">This is a request, not an order; the server may or may not do it.  This option must be set (to any non-NULL value) or else any unsolicited encoding done by the server is ignored. See the special file lib/README.encoding for details. 
<p class="level0"><a name="CURLOPTFOLLOWLOCATION"></a><span class="nroffip">CURLOPT_FOLLOWLOCATION</span> 
<p class="level1">A non-zero parameter tells the library to follow any Location: header that the server sends as part of a HTTP header. 
<p class="level1"><span Class="bold">NOTE:</span> this means that the library will re-send the same request on the new location and follow new Location: headers all the way until no more such headers are returned. <a class="emphasis" href="#CURLOPTMAXREDIRS">CURLOPT_MAXREDIRS</a> can be used to limit the number of redirects libcurl will follow. 
<p class="level0"><a name="CURLOPTUNRESTRICTEDAUTH"></a><span class="nroffip">CURLOPT_UNRESTRICTED_AUTH</span> 
<p class="level1">A non-zero parameter tells the library it can continue to send authentication (user+password) when following locations, even when hostname changed. Note that this is meaningful only when setting <a class="emphasis" href="#CURLOPTFOLLOWLOCATION">CURLOPT_FOLLOWLOCATION</a>. 
<p class="level0"><a name="CURLOPTMAXREDIRS"></a><span class="nroffip">CURLOPT_MAXREDIRS</span> 
<p class="level1">Pass a long. The set number will be the redirection limit. If that many redirections have been followed, the next redirect will cause an error (<span Class="emphasis">CURLE_TOO_MANY_REDIRECTS</span>). This option only makes sense if the <a class="emphasis" href="#CURLOPTFOLLOWLOCATION">CURLOPT_FOLLOWLOCATION</a> is used at the same time. 
<p class="level0"><a name="CURLOPTPUT"></a><span class="nroffip">CURLOPT_PUT</span> 
<p class="level1">A non-zero parameter tells the library to use HTTP PUT to transfer data. The data should be set with <a class="emphasis" href="#CURLOPTREADDATA">CURLOPT_READDATA</a> and <a class="emphasis" href="#CURLOPTINFILESIZE">CURLOPT_INFILESIZE</a>. 
<p class="level0"><a name="CURLOPTPOST"></a><span class="nroffip">CURLOPT_POST</span> 
<p class="level1">A non-zero parameter tells the library to do a regular HTTP post. This is a normal application/x-www-form-urlencoded kind, which is the most commonly used one by HTML forms. See the <a class="emphasis" href="#CURLOPTPOSTFIELDS">CURLOPT_POSTFIELDS</a> option for how to specify the data to post and <a class="emphasis" href="#CURLOPTPOSTFIELDSIZE">CURLOPT_POSTFIELDSIZE</a> in how to set the data size. Using the <a class="emphasis" href="#CURLOPTPOSTFIELDS">CURLOPT_POSTFIELDS</a> option implies this option. 
<p class="level0"><a name="CURLOPTPOSTFIELDS"></a><span class="nroffip">CURLOPT_POSTFIELDS</span> 
<p class="level1">Pass a char * as parameter, which should be the full data to post in a HTTP post operation. You need to make sure that the data is formatted the way you want the server to receive it. libcurl will not convert or encode it for you. Most web servers will assume this data to be url-encoded. Take note. 
<p class="level1">This POST is a normal application/x-www-form-urlencoded kind (and libcurl will set that Content-Type by default when this option is used), which is the most commonly used one by HTML forms. See also the <a class="emphasis" href="#CURLOPTPOST">CURLOPT_POST</a>. Using <a class="emphasis" href="#CURLOPTPOSTFIELDS">CURLOPT_POSTFIELDS</a> implies <a class="emphasis" href="#CURLOPTPOST">CURLOPT_POST</a>. 
<p class="level1"><span Class="bold">Note:</span> to make multipart/formdata posts (aka rfc1867-posts), check out the <a class="emphasis" href="#CURLOPTHTTPPOST">CURLOPT_HTTPPOST</a> option. 
<p class="level0"><a name="CURLOPTPOSTFIELDSIZE"></a><span class="nroffip">CURLOPT_POSTFIELDSIZE</span> 
<p class="level1">If you want to post data to the server without letting libcurl do a strlen() to measure the data size, this option must be used. When this option is used you can post fully binary data, which otherwise is likely to fail. If this size is set to zero, the library will use strlen() to get the size. 
<p class="level0"><a name="CURLOPTPOSTFIELDSIZELARGE"></a><span class="nroffip">CURLOPT_POSTFIELDSIZE_LARGE</span> 
<p class="level1">Pass a curl_off_t as parameter. Use this to set the size of the <a class="emphasis" href="#CURLOPTPOSTFIELDS">CURLOPT_POSTFIELDS</a> data to prevent libcurl from doing strlen() on the data to figure out the size. This is the large file version of the <a class="emphasis" href="#CURLOPTPOSTFIELDSIZE">CURLOPT_POSTFIELDSIZE</a> option. (Added in 7.11.1) 
<p class="level0"><a name="CURLOPTHTTPPOST"></a><span class="nroffip">CURLOPT_HTTPPOST</span> 
<p class="level1">Tells libcurl you want a multipart/formdata HTTP POST to be made and you instruct what data to pass on to the server.  Pass a pointer to a linked list of HTTP post structs as parameter.  The linked list should be a fully valid list of 'struct HttpPost' structs properly filled in. The best and most elegant way to do this, is to use <a class="emphasis" href="./curl_formadd.html">curl_formadd(3)</a> as documented. The data in this list must remain intact until you close this curl handle again with <a class="emphasis" href="./curl_easy_cleanup.html">curl_easy_cleanup(3)</a>. 
<p class="level0"><a name="CURLOPTREFERER"></a><span class="nroffip">CURLOPT_REFERER</span> 
<p class="level1">Pass a pointer to a zero terminated string as parameter. It will be used to set the Referer: header in the http request sent to the remote server. This can be used to fool servers or scripts. You can also set any custom header with <a class="emphasis" href="#CURLOPTHTTPHEADER">CURLOPT_HTTPHEADER</a>. 
<p class="level0"><a name="CURLOPTUSERAGENT"></a><span class="nroffip">CURLOPT_USERAGENT</span> 
<p class="level1">Pass a pointer to a zero terminated string as parameter. It will be used to set the User-Agent: header in the http request sent to the remote server. This can be used to fool servers or scripts. You can also set any custom header with <a class="emphasis" href="#CURLOPTHTTPHEADER">CURLOPT_HTTPHEADER</a>. 
<p class="level0"><a name="CURLOPTHTTPHEADER"></a><span class="nroffip">CURLOPT_HTTPHEADER</span> 
<p class="level1">Pass a pointer to a linked list of HTTP headers to pass to the server in your HTTP request. The linked list should be a fully valid list of <span class="bold">struct curl_slist</span> structs properly filled in. Use <a class="emphasis" href="./curl_slist_append.html">curl_slist_append(3)</a> to create the list and <a class="emphasis" href="./curl_slist_free_all.html">curl_slist_free_all(3)</a> to clean up an entire list. If you add a header that is otherwise generated and used by libcurl internally, your added one will be used instead. If you add a header with no contents as in 'Accept:' (no data on the right side of the colon), the internally used header will get disabled. Thus, using this option you can add new headers, replace internal headers and remove internal headers. The headers included in the linked list must not be CRLF-terminated, because curl adds CRLF after each header item. Failure to comply with this will result in strange bugs because the server will most likely ignore part of the headers you specified. 
<p class="level1">The first line in a request (usually containing a GET or POST) is not a header and cannot be replaced using this option. Only the lines following the request-line are headers. 
<p class="level1"><span Class="bold">NOTE:</span>The most commonly replaced headers have "shortcuts" in the options <a class="emphasis" href="#CURLOPTCOOKIE">CURLOPT_COOKIE</a>, <a class="emphasis" href="#CURLOPTUSERAGENT">CURLOPT_USERAGENT</a> and <a class="emphasis" href="#CURLOPTREFERER">CURLOPT_REFERER</a>. 
<p class="level0"><a name="CURLOPTHTTP200ALIASES"></a><span class="nroffip">CURLOPT_HTTP200ALIASES</span> 
<p class="level1">Pass a pointer to a linked list of aliases to be treated as valid HTTP 200 responses.  Some servers respond with a custom header response line.  For example, IceCast servers respond with "ICY 200 OK".  By including this string in your list of aliases, the response will be treated as a valid HTTP header line such as "HTTP/1.0 200 OK". (Added in 7.10.3) 
<p class="level1">The linked list should be a fully valid list of struct curl_slist structs, and be properly filled in.  Use <a class="emphasis" href="./curl_slist_append.html">curl_slist_append(3)</a> to create the list and <a class="emphasis" href="./curl_slist_free_all.html">curl_slist_free_all(3)</a> to clean up an entire list. 
<p class="level1"><span Class="bold">NOTE:</span>The alias itself is not parsed for any version strings.  So if your alias is "MYHTTP/9.9", Libcurl will not treat the server as responding with HTTP version 9.9.  Instead Libcurl will use the value set by option <a class="emphasis" href="#CURLOPTHTTPVERSION">CURLOPT_HTTP_VERSION</a>. 
<p class="level0"><a name="CURLOPTCOOKIE"></a><span class="nroffip">CURLOPT_COOKIE</span> 
<p class="level1">Pass a pointer to a zero terminated string as parameter. It will be used to set a cookie in the http request. The format of the string should be NAME=CONTENTS, where NAME is the cookie name and CONTENTS is what the cookie should contain. 
<p class="level1">If you need to set mulitple cookies, you need to set them all using a single option and thus you need to concat them all in one single string. Set multiple cookies in one string like this: "name1=content1; name2=content2;" etc. 
<p class="level1">Using this option multiple times will only make the latest string override the previously ones. 
<p class="level0"><a name="CURLOPTCOOKIEFILE"></a><span class="nroffip">CURLOPT_COOKIEFILE</span> 
<p class="level1">Pass a pointer to a zero terminated string as parameter. It should contain the name of your file holding cookie data to read. The cookie data may be in Netscape / Mozilla cookie data format or just regular HTTP-style headers dumped to a file. 
<p class="level1">Given an empty or non-existing file, this option will enable cookies for this curl handle, making it understand and parse received cookies and then use matching cookies in future request. 
<p class="level0"><a name="CURLOPTCOOKIEJAR"></a><span class="nroffip">CURLOPT_COOKIEJAR</span> 
<p class="level1">Pass a file name as char *, zero terminated. This will make libcurl write all internally known cookies to the specified file when <a class="emphasis" href="./curl_easy_cleanup.html">curl_easy_cleanup(3)</a> is called. If no cookies are known, no file will be created. Specify "-" to instead have the cookies written to stdout. Using this option also enables cookies for this session, so if you for example follow a location it will make matching cookies get sent accordingly. 
<p class="level1"><span Class="bold">NOTE:</span> If the cookie jar file can't be created or written to (when the <a class="emphasis" href="./curl_easy_cleanup.html">curl_easy_cleanup(3)</a> is called), libcurl will not and cannot report an error for this. Using <a class="emphasis" href="#CURLOPTVERBOSE">CURLOPT_VERBOSE</a> or <a class="emphasis" href="#CURLOPTDEBUGFUNCTION">CURLOPT_DEBUGFUNCTION</a> will get a warning to display, but that is the only visible feedback you get about this possibly lethal situation. 
<p class="level0"><a name="CURLOPTCOOKIESESSION"></a><span class="nroffip">CURLOPT_COOKIESESSION</span> 
<p class="level1">Pass a long set to non-zero to mark this as a new cookie "session". It will force libcurl to ignore all cookies it is about to load that are "session cookies" from the previous session. By default, libcurl always stores and loads all cookies, independent if they are session cookies are not. Session cookies are cookies without expiry date and they are meant to be alive and existing for this "session" only. 
<p class="level0"><a name="CURLOPTHTTPGET"></a><span class="nroffip">CURLOPT_HTTPGET</span> 
<p class="level1">Pass a long. If the long is non-zero, this forces the HTTP request to get back to GET. Only really usable if POST, PUT or a custom request have been used previously using the same curl handle. 
<p class="level0"><a name="CURLOPTHTTPVERSION"></a><span class="nroffip">CURLOPT_HTTP_VERSION</span> 
<p class="level1">Pass a long, set to one of the values described below. They force libcurl to use the specific HTTP versions. This is not sensible to do unless you have a good reason. 
<p class="level2">
<p class="level1"><a name="CURLHTTPVERSIONNONE"></a><span class="nroffip">CURL_HTTP_VERSION_NONE</span> 
<p class="level2">We don't care about what version the library uses. libcurl will use whatever it thinks fit. 
<p class="level1"><a name="CURLHTTPVERSION10"></a><span class="nroffip">CURL_HTTP_VERSION_1_0</span> 
<p class="level2">Enforce HTTP 1.0 requests. 
<p class="level1"><a name="CURLHTTPVERSION11"></a><span class="nroffip">CURL_HTTP_VERSION_1_1</span> 
<p class="level2">Enforce HTTP 1.1 requests. 
<p class="level1"><a name="FTP"></a><h2 class="nroffsh">FTP OPTIONS</h2>
<p class="level0">
<p class="level0"><a name="CURLOPTFTPPORT"></a><span class="nroffip">CURLOPT_FTPPORT</span> 
<p class="level1">Pass a pointer to a zero terminated string as parameter. It will be used to get the IP address to use for the ftp PORT instruction. The PORT instruction tells the remote server to connect to our specified IP address. The string may be a plain IP address, a host name, an network interface name (under Unix) or just a '-' letter to let the library use your systems default IP address. Default FTP operations are passive, and thus won't use PORT. 
<p class="level1">You disable PORT again and go back to using the passive version by setting this option to NULL. 
<p class="level0"><a name="CURLOPTQUOTE"></a><span class="nroffip">CURLOPT_QUOTE</span> 
<p class="level1">Pass a pointer to a linked list of FTP commands to pass to the server prior to your ftp request. This will be done before any other FTP commands are issued (even before the CWD command). The linked list should be a fully valid list of 'struct curl_slist' structs properly filled in. Use <a class="emphasis" href="./curl_slist_append.html">curl_slist_append(3)</a> to append strings (commands) to the list, and clear the entire list afterwards with <a class="emphasis" href="./curl_slist_free_all.html">curl_slist_free_all(3)</a>. Disable this operation again by setting a NULL to this option. 
<p class="level0"><a name="CURLOPTPOSTQUOTE"></a><span class="nroffip">CURLOPT_POSTQUOTE</span> 
<p class="level1">Pass a pointer to a linked list of FTP commands to pass to the server after your ftp transfer request. The linked list should be a fully valid list of struct curl_slist structs properly filled in as described for <a class="emphasis" href="#CURLOPTQUOTE">CURLOPT_QUOTE</a>. Disable this operation again by setting a NULL to this option. 
<p class="level0"><a name="CURLOPTPREQUOTE"></a><span class="nroffip">CURLOPT_PREQUOTE</span> 
<p class="level1">Pass a pointer to a linked list of FTP commands to pass to the server after the transfer type is set. The linked list should be a fully valid list of struct curl_slist structs properly filled in as described for <a class="emphasis" href="#CURLOPTQUOTE">CURLOPT_QUOTE</a>. Disable this operation again by setting a NULL to this option. 
<p class="level0"><a name="CURLOPTFTPLISTONLY"></a><span class="nroffip">CURLOPT_FTPLISTONLY</span> 
<p class="level1">A non-zero parameter tells the library to just list the names of an ftp directory, instead of doing a full directory listing that would include file sizes, dates etc. 
<p class="level1">This causes an FTP NLST command to be sent.  Beware that some FTP servers list only files in their response to NLST; they might not include subdirectories and symbolic links. 
<p class="level0"><a name="CURLOPTFTPAPPEND"></a><span class="nroffip">CURLOPT_FTPAPPEND</span> 
<p class="level1">A non-zero parameter tells the library to append to the remote file instead of overwrite it. This is only useful when uploading to a ftp site. 
<p class="level0"><a name="CURLOPTFTPUSEEPRT"></a><span class="nroffip">CURLOPT_FTP_USE_EPRT</span> 
<p class="level1">Pass a long. If the value is non-zero, it tells curl to use the EPRT (and LPRT) command when doing active FTP downloads (which is enabled by <a class="emphasis" href="#CURLOPTFTPPORT">CURLOPT_FTPPORT</a>). Using EPRT means that it will first attempt to use EPRT and then LPRT before using PORT, but if you pass FALSE (zero) to this option, it will not try using EPRT or LPRT, only plain PORT. (Added in 7.10.5) 
<p class="level0"><a name="CURLOPTFTPUSEEPSV"></a><span class="nroffip">CURLOPT_FTP_USE_EPSV</span> 
<p class="level1">Pass a long. If the value is non-zero, it tells curl to use the EPSV command when doing passive FTP downloads (which it always does by default). Using EPSV means that it will first attempt to use EPSV before using PASV, but if you pass FALSE (zero) to this option, it will not try using EPSV, only plain PASV. 
<p class="level0"><a name="CURLOPTFTPCREATEMISSINGDIRS"></a><span class="nroffip">CURLOPT_FTP_CREATE_MISSING_DIRS</span> 
<p class="level1">Pass a long. If the value is non-zero, curl will attempt to create any remote directory that it fails to CWD into. CWD is the command that changes working directory. (Added in 7.10.7) 
<p class="level0"><a name="CURLOPTFTPRESPONSETIMEOUT"></a><span class="nroffip">CURLOPT_FTP_RESPONSE_TIMEOUT</span> 
<p class="level1">Pass a long.  Causes curl to set a timeout period (in seconds) on the amount of time that the server is allowed to take in order to generate a response message for a command before the session is considered hung.  Note that while curl is waiting for a response, this value overrides <a class="emphasis" href="#CURLOPTTIMEOUT">CURLOPT_TIMEOUT</a>. It is recommended that if used in conjunction with <a class="emphasis" href="#CURLOPTTIMEOUT">CURLOPT_TIMEOUT</a>, you set <a class="emphasis" href="#CURLOPTFTPRESPONSETIMEOUT">CURLOPT_FTP_RESPONSE_TIMEOUT</a> to a value smaller than <a class="emphasis" href="#CURLOPTTIMEOUT">CURLOPT_TIMEOUT</a>.  (Added in 7.10.8) 
<p class="level0"><a name="CURLOPTFTPSSL"></a><span class="nroffip">CURLOPT_FTP_SSL</span> 
<p class="level1">Pass a long using one of the values from below, to make libcurl use your desired level of SSL for the ftp transfer. (Added in 7.11.0) 
<p class="level2">
<p class="level1"><a name="CURLFTPSSLNONE"></a><span class="nroffip">CURLFTPSSL_NONE</span> 
<p class="level2">Don't attempt to use SSL. 
<p class="level1"><a name="CURLFTPSSLTRY"></a><span class="nroffip">CURLFTPSSL_TRY</span> 
<p class="level2">Try using SSL, proceed as normal otherwise. 
<p class="level1"><a name="CURLFTPSSLCONTROL"></a><span class="nroffip">CURLFTPSSL_CONTROL</span> 
<p class="level2">Require SSL for the control connection or fail with <span Class="emphasis">CURLE_FTP_SSL_FAILED</span>. 
<p class="level1"><a name="CURLFTPSSLALL"></a><span class="nroffip">CURLFTPSSL_ALL</span> 
<p class="level2">Require SSL for all communication or fail with <span Class="emphasis">CURLE_FTP_SSL_FAILED</span>. 
<p class="level1"><a name="PROTOCOL"></a><h2 class="nroffsh">PROTOCOL OPTIONS</h2>
<p class="level0">
<p class="level0"><a name="CURLOPTTRANSFERTEXT"></a><span class="nroffip">CURLOPT_TRANSFERTEXT</span> 
<p class="level1">A non-zero parameter tells the library to use ASCII mode for ftp transfers, instead of the default binary transfer. For LDAP transfers it gets the data in plain text instead of HTML and for win32 systems it does not set the stdout to binary mode. This option can be usable when transferring text data between systems with different views on certain characters, such as newlines or similar. 
<p class="level0"><a name="CURLOPTCRLF"></a><span class="nroffip">CURLOPT_CRLF</span> 
<p class="level1">Convert Unix newlines to CRLF newlines on transfers. 
<p class="level0"><a name="CURLOPTRANGE"></a><span class="nroffip">CURLOPT_RANGE</span> 
<p class="level1">Pass a char * as parameter, which should contain the specified range you want. It should be in the format "X-Y", where X or Y may be left out. HTTP transfers also support several intervals, separated with commas as in <span Class="emphasis">"X-Y,N-M"</span>. Using this kind of multiple intervals will cause the HTTP server to send the response document in pieces (using standard MIME separation techniques). 
<p class="level0"><a name="CURLOPTRESUMEFROM"></a><span class="nroffip">CURLOPT_RESUME_FROM</span> 
<p class="level1">Pass a long as parameter. It contains the offset in number of bytes that you want the transfer to start from. 
<p class="level0"><a name="CURLOPTRESUMEFROMLARGE"></a><span class="nroffip">CURLOPT_RESUME_FROM_LARGE</span> 
<p class="level1">Pass an curl_off_t as parameter. It contains the offset in number of bytes that you want the transfer to start from. (Added in 7.11.0) 
<p class="level0"><a name="CURLOPTCUSTOMREQUEST"></a><span class="nroffip">CURLOPT_CUSTOMREQUEST</span> 
<p class="level1">Pass a pointer to a zero terminated string as parameter. It will be user instead of GET or HEAD when doing a HTTP request, or instead of LIST or NLST when doing an ftp directory listing. This is useful for doing DELETE or other more or less obscure HTTP requests. Don't do this at will, make sure your server supports the command first. 
<p class="level1">NOTE: many people have wrongly used this option to replace the entire request with their own, including multiple headers and POST contents. While that might work in many cases, it will cause libcurl to send invalid requests and it could possibly confuse the remote server badly. Use <a class="emphasis" href="#CURLOPTPOST">CURLOPT_POST</a> and <a class="emphasis" href="#CURLOPTPOSTFIELDS">CURLOPT_POSTFIELDS</a> to set POST data. Use <a class="emphasis" href="#CURLOPTHTTPHEADER">CURLOPT_HTTPHEADER</a> to replace or extend the set of headers sent by libcurl. Use <a class="emphasis" href="#CURLOPTHTTPVERSION">CURLOPT_HTTP_VERSION</a> to change HTTP version. 
<p class="level0"><a name="CURLOPTFILETIME"></a><span class="nroffip">CURLOPT_FILETIME</span> 
<p class="level1">Pass a long. If it is a non-zero value, libcurl will attempt to get the modification date of the remote document in this operation. This requires that the remote server sends the time or replies to a time querying command. The <a class="emphasis" href="./curl_easy_getinfo.html">curl_easy_getinfo(3)</a> function with the <span Class="emphasis">CURLINFO_FILETIME</span> argument can be used after a transfer to extract the received time (if any). 
<p class="level0"><a name="CURLOPTNOBODY"></a><span class="nroffip">CURLOPT_NOBODY</span> 
<p class="level1">A non-zero parameter tells the library to not include the body-part in the output. This is only relevant for protocols that have separate header and body parts. On HTTP(S) servers, this will make libcurl do a HEAD request. 
<p class="level0"><a name="CURLOPTINFILESIZE"></a><span class="nroffip">CURLOPT_INFILESIZE</span> 
<p class="level1">When uploading a file to a remote site, this option should be used to tell libcurl what the expected size of the infile is. This value should be passed as a long. See also <a class="emphasis" href="#CURLOPTINFILESIZELARGE">CURLOPT_INFILESIZE_LARGE</a>. 
<p class="level0"><a name="CURLOPTINFILESIZELARGE"></a><span class="nroffip">CURLOPT_INFILESIZE_LARGE</span> 
<p class="level1">When uploading a file to a remote site, this option should be used to tell libcurl what the expected size of the infile is.  This value should be passed as a curl_off_t. (Added in 7.11.0) 
<p class="level0"><a name="CURLOPTUPLOAD"></a><span class="nroffip">CURLOPT_UPLOAD</span> 
<p class="level1">A non-zero parameter tells the library to prepare for an upload. The <a class="emphasis" href="#CURLOPTREADDATA">CURLOPT_READDATA</a> and <a class="emphasis" href="#CURLOPTINFILESIZELARGE">CURLOPT_INFILESIZE_LARGE</a> are also interesting for uploads. 
<p class="level0"><a name="CURLOPTMAXFILESIZE"></a><span class="nroffip">CURLOPT_MAXFILESIZE</span> 
<p class="level1">Pass a long as parameter. This allows you to specify the maximum size (in bytes) of a file to download. If the file requested is larger than this value, the transfer will not start and CURLE_FILESIZE_EXCEEDED will be returned. 
<p class="level1">NOTE: The file size is not always known prior to download, and for such files this option has no effect even if the file transfer ends up being larger than this given limit. This concerns both FTP and HTTP transfers. 
<p class="level0"><a name="CURLOPTMAXFILESIZELARGE"></a><span class="nroffip">CURLOPT_MAXFILESIZE_LARGE</span> 
<p class="level1">Pass a curl_off_t as parameter. This allows you to specify the maximum size (in bytes) of a file to download. If the file requested is larger than this value, the transfer will not start and <span Class="emphasis">CURLE_FILESIZE_EXCEEDED</span> will be returned. (Added in 7.11.0) 
<p class="level1">NOTE: The file size is not always known prior to download, and for such files this option has no effect even if the file transfer ends up being larger than this given limit. This concerns both FTP and HTTP transfers. 
<p class="level0"><a name="CURLOPTTIMECONDITION"></a><span class="nroffip">CURLOPT_TIMECONDITION</span> 
<p class="level1">Pass a long as parameter. This defines how the <a class="emphasis" href="#CURLOPTTIMEVALUE">CURLOPT_TIMEVALUE</a> time value is treated. You can set this parameter to <span Class="emphasis">CURL_TIMECOND_IFMODSINCE</span> or <span Class="emphasis">CURL_TIMECOND_IFUNMODSINCE</span>. This feature applies to HTTP and FTP. 
<p class="level1">NOTE: The last modification time of a file is not always known and in such instances this feature will have no effect even if the given time condition would have not been met. 
<p class="level0"><a name="CURLOPTTIMEVALUE"></a><span class="nroffip">CURLOPT_TIMEVALUE</span> 
<p class="level1">Pass a long as parameter. This should be the time in seconds since 1 jan 1970, and the time will be used in a condition as specified with  <a class="emphasis" href="#CURLOPTTIMECONDITION">CURLOPT_TIMECONDITION</a>. <a name="CONNECTION"></a><h2 class="nroffsh">CONNECTION OPTIONS</h2>
<p class="level0">
<p class="level0"><a name="CURLOPTTIMEOUT"></a><span class="nroffip">CURLOPT_TIMEOUT</span> 
<p class="level1">Pass a long as parameter containing the maximum time in seconds that you allow the libcurl transfer operation to take. Normally, name lookups can take a considerable time and limiting operations to less than a few minutes risk aborting perfectly normal operations. This option will cause curl to use the SIGALRM to enable time-outing system calls. 
<p class="level1"><span Class="bold">NOTE:</span> this is not recommended to use in unix multi-threaded programs, as it uses signals unless <a class="emphasis" href="#CURLOPTNOSIGNAL">CURLOPT_NOSIGNAL</a> (see above) is set. 
<p class="level0"><a name="CURLOPTLOWSPEEDLIMIT"></a><span class="nroffip">CURLOPT_LOW_SPEED_LIMIT</span> 
<p class="level1">Pass a long as parameter. It contains the transfer speed in bytes per second that the transfer should be below during <a class="emphasis" href="#CURLOPTLOWSPEEDTIME">CURLOPT_LOW_SPEED_TIME</a> seconds for the library to consider it too slow and abort. 
<p class="level0"><a name="CURLOPTLOWSPEEDTIME"></a><span class="nroffip">CURLOPT_LOW_SPEED_TIME</span> 
<p class="level1">Pass a long as parameter. It contains the time in seconds that the transfer should be below the <a class="emphasis" href="#CURLOPTLOWSPEEDLIMIT">CURLOPT_LOW_SPEED_LIMIT</a> for the library to consider it too slow and abort. 
<p class="level0"><a name="CURLOPTMAXCONNECTS"></a><span class="nroffip">CURLOPT_MAXCONNECTS</span> 
<p class="level1">Pass a long. The set number will be the persistent connection cache size. The set amount will be the maximum amount of simultaneously open connections that libcurl may cache. Default is 5, and there isn't much point in changing this value unless you are perfectly aware of how this work and changes libcurl's behaviour. This concerns connection using any of the protocols that support persistent connections. 
<p class="level1">When reaching the maximum limit, curl uses the <a class="emphasis" href="#CURLOPTCLOSEPOLICY">CURLOPT_CLOSEPOLICY</a> to figure out which of the existing connections to close to prevent the number of open connections to increase. 
<p class="level1"><span Class="bold">NOTE:</span> if you already have performed transfers with this curl handle, setting a smaller MAXCONNECTS than before may cause open connections to get closed unnecessarily. 
<p class="level0"><a name="CURLOPTCLOSEPOLICY"></a><span class="nroffip">CURLOPT_CLOSEPOLICY</span> 
<p class="level1">Pass a long. This option sets what policy libcurl should use when the connection cache is filled and one of the open connections has to be closed to make room for a new connection. This must be one of the CURLCLOSEPOLICY_* defines. Use <span Class="emphasis">CURLCLOSEPOLICY_LEAST_RECENTLY_USED</span> to make libcurl close the connection that was least recently used, that connection is also least likely to be capable of re-use. Use <span Class="emphasis">CURLCLOSEPOLICY_OLDEST</span> to make libcurl close the oldest connection, the one that was created first among the ones in the connection cache. The other close policies are not support yet. 
<p class="level0"><a name="CURLOPTFRESHCONNECT"></a><span class="nroffip">CURLOPT_FRESH_CONNECT</span> 
<p class="level1">Pass a long. Set to non-zero to make the next transfer use a new (fresh) connection by force. If the connection cache is full before this connection, one of the existing connections will be closed as according to the selected or default policy. This option should be used with caution and only if you understand what it does. Set this to 0 to have libcurl attempt re-using an existing connection (default behavior). 
<p class="level0"><a name="CURLOPTFORBIDREUSE"></a><span class="nroffip">CURLOPT_FORBID_REUSE</span> 
<p class="level1">Pass a long. Set to non-zero to make the next transfer explicitly close the connection when done. Normally, libcurl keep all connections alive when done with one transfer in case there comes a succeeding one that can re-use them. This option should be used with caution and only if you understand what it does. Set to 0 to have libcurl keep the connection open for possibly later re-use (default behavior). 
<p class="level0"><a name="CURLOPTCONNECTTIMEOUT"></a><span class="nroffip">CURLOPT_CONNECTTIMEOUT</span> 
<p class="level1">Pass a long. It should contain the maximum time in seconds that you allow the connection to the server to take.  This only limits the connection phase, once it has connected, this option is of no more use. Set to zero to disable connection timeout (it will then only timeout on the system's internal timeouts). See also the <a class="emphasis" href="#CURLOPTTIMEOUT">CURLOPT_TIMEOUT</a> option. 
<p class="level1"><span Class="bold">NOTE:</span> this is not recommended to use in unix multi-threaded programs, as it uses signals unless <a class="emphasis" href="#CURLOPTNOSIGNAL">CURLOPT_NOSIGNAL</a> (see above) is set. 
<p class="level0"><a name="CURLOPTIPRESOLVE"></a><span class="nroffip">CURLOPT_IPRESOLVE</span> 
<p class="level1">Allows an application to select what kind of IP addresses to use when resolving host names. This is only interesting when using host names that resolve addresses using more than one version of IP. The allowed values are: 
<p class="level2">
<p class="level1"><a name="CURLIPRESOLVEWHATEVER"></a><span class="nroffip">CURL_IPRESOLVE_WHATEVER</span> 
<p class="level2">Default, resolves addresses to all IP versions that your system allows. 
<p class="level1"><a name="CURLIPRESOLVEV4"></a><span class="nroffip">CURL_IPRESOLVE_V4</span> 
<p class="level2">Resolve to ipv4 addresses. 
<p class="level1"><a name="CURLIPRESOLVEV6"></a><span class="nroffip">CURL_IPRESOLVE_V6</span> 
<p class="level2">Resolve to ipv6 addresses. 
<p class="level1"><a name="SSL"></a><h2 class="nroffsh">SSL and SECURITY OPTIONS</h2>
<p class="level0">
<p class="level0"><a name="CURLOPTSSLCERT"></a><span class="nroffip">CURLOPT_SSLCERT</span> 
<p class="level1">Pass a pointer to a zero terminated string as parameter. The string should be the file name of your certificate. The default format is "PEM" and can be changed with <a class="emphasis" href="#CURLOPTSSLCERTTYPE">CURLOPT_SSLCERTTYPE</a>. 
<p class="level0"><a name="CURLOPTSSLCERTTYPE"></a><span class="nroffip">CURLOPT_SSLCERTTYPE</span> 
<p class="level1">Pass a pointer to a zero terminated string as parameter. The string should be the format of your certificate. Supported formats are "PEM" and "DER".  (Added in 7.9.3) 
<p class="level0"><a name="CURLOPTSSLCERTPASSWD"></a><span class="nroffip">CURLOPT_SSLCERTPASSWD</span> 
<p class="level1">Pass a pointer to a zero terminated string as parameter. It will be used as the password required to use the <a class="emphasis" href="#CURLOPTSSLCERT">CURLOPT_SSLCERT</a> certificate. 
<p class="level1">This option is replaced by <a class="emphasis" href="#CURLOPTSSLKEYPASSWD">CURLOPT_SSLKEYPASSWD</a> and should only be used for backward compatibility. You never needed a pass phrase to load a certificate but you need one to load your private key. 
<p class="level0"><a name="CURLOPTSSLKEY"></a><span class="nroffip">CURLOPT_SSLKEY</span> 
<p class="level1">Pass a pointer to a zero terminated string as parameter. The string should be the file name of your private key. The default format is "PEM" and can be changed with <a class="emphasis" href="#CURLOPTSSLKEYTYPE">CURLOPT_SSLKEYTYPE</a>. 
<p class="level0"><a name="CURLOPTSSLKEYTYPE"></a><span class="nroffip">CURLOPT_SSLKEYTYPE</span> 
<p class="level1">Pass a pointer to a zero terminated string as parameter. The string should be the format of your private key. Supported formats are "PEM", "DER" and "ENG". 
<p class="level1"><span Class="bold">NOTE:</span>The format "ENG" enables you to load the private key from a crypto engine. in this case <a class="emphasis" href="#CURLOPTSSLKEY">CURLOPT_SSLKEY</a> is used as an identifier passed to the engine. You have to set the crypto engine with <a class="emphasis" href="#CURLOPTSSLENGINE">CURLOPT_SSLENGINE</a>. 
<p class="level0"><a name="CURLOPTSSLKEYPASSWD"></a><span class="nroffip">CURLOPT_SSLKEYPASSWD</span> 
<p class="level1">Pass a pointer to a zero terminated string as parameter. It will be used as the password required to use the <a class="emphasis" href="#CURLOPTSSLKEY">CURLOPT_SSLKEY</a> private key. 
<p class="level0"><a name="CURLOPTSSLENGINE"></a><span class="nroffip">CURLOPT_SSLENGINE</span> 
<p class="level1">Pass a pointer to a zero terminated string as parameter. It will be used as the identifier for the crypto engine you want to use for your private key. 
<p class="level1"><span Class="bold">NOTE:</span>If the crypto device cannot be loaded, <span Class="emphasis">CURLE_SSL_ENGINE_NOTFOUND</span> is returned. 
<p class="level0"><a name="CURLOPTSSLENGINEDEFAULT"></a><span class="nroffip">CURLOPT_SSLENGINE_DEFAULT</span> 
<p class="level1">Sets the actual crypto engine as the default for (asymetric) crypto operations. 
<p class="level1"><span Class="bold">NOTE:</span>If the crypto device cannot be set, <span Class="emphasis">CURLE_SSL_ENGINE_SETFAILED</span> is returned. 
<p class="level0"><a name="CURLOPTSSLVERSION"></a><span class="nroffip">CURLOPT_SSLVERSION</span> 
<p class="level1">Pass a long as parameter. Set what version of SSL to attempt to use, 2 or 3. By default, the SSL library will try to solve this by itself although some servers make this difficult why you at times may have to use this option. 
<p class="level0"><a name="CURLOPTSSLVERIFYPEER"></a><span class="nroffip">CURLOPT_SSL_VERIFYPEER</span> 
<p class="level1">Pass a long that is set to a zero value to stop curl from verifying the peer's certificate (7.10 starting setting this option to non-zero by default). Alternate certificates to verify against can be specified with the <a class="emphasis" href="#CURLOPTCAINFO">CURLOPT_CAINFO</a> option or a certificate directory can be specified with the <a class="emphasis" href="#CURLOPTCAPATH">CURLOPT_CAPATH</a> option.  As of 7.10, curl installs a default bundle. <a class="emphasis" href="#CURLOPTSSLVERIFYHOST">CURLOPT_SSL_VERIFYHOST</a> may also need to be set to 1 or 0 if <a class="emphasis" href="#CURLOPTSSLVERIFYPEER">CURLOPT_SSL_VERIFYPEER</a> is disabled (it defaults to 2). 
<p class="level0"><a name="CURLOPTCAINFO"></a><span class="nroffip">CURLOPT_CAINFO</span> 
<p class="level1">Pass a char * to a zero terminated string naming a file holding one or more certificates to verify the peer with. This only makes sense when used in combination with the <a class="emphasis" href="#CURLOPTSSLVERIFYPEER">CURLOPT_SSL_VERIFYPEER</a> option. 
<p class="level0"><a name="CURLOPTCAPATH"></a><span class="nroffip">CURLOPT_CAPATH</span> 
<p class="level1">Pass a char * to a zero terminated string naming a directory holding multiple CA certificates to verify the peer with. The certificate directory must be prepared using the openssl c_rehash utility. This only makes sense when used in combination with the <a class="emphasis" href="#CURLOPTSSLVERIFYPEER">CURLOPT_SSL_VERIFYPEER</a> option. The <a class="emphasis" href="#CURLOPTCAPATH">CURLOPT_CAPATH</a> function apparently does not work in Windows due to some limitation in openssl. (Added in 7.9.8) 
<p class="level0"><a name="CURLOPTRANDOMFILE"></a><span class="nroffip">CURLOPT_RANDOM_FILE</span> 
<p class="level1">Pass a char * to a zero terminated file name. The file will be used to read from to seed the random engine for SSL. The more random the specified file is, the more secure the SSL connection will become. 
<p class="level0"><a name="CURLOPTEGDSOCKET"></a><span class="nroffip">CURLOPT_EGDSOCKET</span> 
<p class="level1">Pass a char * to the zero terminated path name to the Entropy Gathering Daemon socket. It will be used to seed the random engine for SSL. 
<p class="level0"><a name="CURLOPTSSLVERIFYHOST"></a><span class="nroffip">CURLOPT_SSL_VERIFYHOST</span> 
<p class="level1">Pass a long. Set if we should verify the Common name from the peer certificate in the SSL handshake, set 1 to check existence, 2 to ensure that it matches the provided hostname. This is by default set to 2. (default changed in 7.10) 
<p class="level0"><a name="CURLOPTSSLCIPHERLIST"></a><span class="nroffip">CURLOPT_SSL_CIPHER_LIST</span> 
<p class="level1">Pass a char *, pointing to a zero terminated string holding the list of ciphers to use for the SSL connection. The list must be syntactly correct, it consists of one or more cipher strings separated by colons. Commas or spaces are also acceptable separators but colons are normally used, !, - and + can be used as operators. Valid examples of cipher lists include 'RC4-SHA', &acute;SHA1+DES&acute;, 'TLSv1' and 'DEFAULT'. The default list is normally set when you compile OpenSSL. 
<p class="level1">You'll find more details about cipher lists on this URL: <span Class="emphasis"><a href="http://www.openssl.org/docs/apps/ciphers.html">http://www.openssl.org/docs/apps/ciphers.html</a></span> 
<p class="level0"><a name="CURLOPTKRB4LEVEL"></a><span class="nroffip">CURLOPT_KRB4LEVEL</span> 
<p class="level1">Pass a char * as parameter. Set the krb4 security level, this also enables krb4 awareness.  This is a string, 'clear', 'safe', 'confidential' or &zerosp;'private'.  If the string is set but doesn't match one of these, 'private' will be used. Set the string to NULL to disable kerberos4. The kerberos support only works for FTP. <a name="OTHER"></a><h2 class="nroffsh">OTHER OPTIONS</h2>
<p class="level0">
<p class="level0"><a name="CURLOPTPRIVATE"></a><span class="nroffip">CURLOPT_PRIVATE</span> 
<p class="level1">Pass a char * as parameter, pointing to data that should be associated with this curl handle.  The pointer can subsequently be retrieved using <a class="emphasis" href="./curl_easy_getinfo.html">curl_easy_getinfo(3)</a> with the CURLINFO_PRIVATE option. libcurl itself does nothing with this data. (Added in 7.10.3) 
<p class="level0"><a name="CURLOPTSHARE"></a><span class="nroffip">CURLOPT_SHARE</span> 
<p class="level1">Pass a share handle as a parameter. The share handle must have been created by a previous call to <a class="emphasis" href="./curl_share_init.html">curl_share_init(3)</a>. Setting this option, will make this curl handle use the data from the shared handle instead of keeping the data to itself. This enables several curl handles to share data. If the curl handles are used simultaneously, you <span Class="bold">MUST</span> use the locking methods in the share handle. See <a class="emphasis" href="./curl_share_setopt.html">curl_share_setopt(3)</a> for details. <a name="TELNET"></a><h2 class="nroffsh">TELNET OPTIONS</h2>
<p class="level0">
<p class="level0"><a name="CURLOPTTELNETOPTIONS"></a><span class="nroffip">CURLOPT_TELNETOPTIONS</span> 
<p class="level1">Provide a pointer to a curl_slist with variables to pass to the telnet negotiations. The variables should be in the format &lt;option=value&gt;. libcurl supports the options 'TTYPE', 'XDISPLOC' and 'NEW_ENV'. See the TELNET standard for details. <a name="RETURN"></a><h2 class="nroffsh">RETURN VALUE</h2>
<p class="level0">CURLE_OK (zero) means that the option was set properly, non-zero means an error occurred as <span Class="emphasis">&lt;curl/curl.h&gt;</span> defines. See the <span Class="emphasis">libcurl-errors(3)</span> man page for the full list with descriptions. <a name="SEE"></a><h2 class="nroffsh">SEE ALSO</h2>
<p class="level0"><a class="manpage" href="./curl_easy_init.html">curl_easy_init (3)</a> <a class="manpage" href="./curl_easy_cleanup.html">  curl_easy_cleanup (3)</a> <span Class="manpage"> </span> <p class="roffit">
 This HTML page was made with <a href="http://daniel.haxx.se/projects/roffit/">roffit</a>.
</body></html>
